# MCP Server 多账号权限传递改造需求分析

## 1. 背景说明

### 1.1 架构概述
```
┌─────────────────┐
│ Strands Agent   │  (AgentCore Runtime)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ AgentCore       │  (权限网关)
│ Gateway         │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ MCP Servers     │  (AgentCore Runtime)
│ (多个后端服务)   │
└─────────────────┘
```

### 1.2 核心问题
**问题**：Strands Agent 需要访问**目标账号**的 AWS 资源，但 MCP Server 默认使用**运行时账号**的凭证。

**场景示例**：
- Agent 运行在 Account A (运行时账号)
- 用户想查询 Account B (目标账号) 的成本数据
- MCP Server 需要获取 Account B 的临时凭证

### 1.3 解决方案
通过 **账号上下文传递机制** 实现：
1. Agent 通过 Gateway 传递 `target_account_id` 参数
2. MCP Server 从数据库查询账号凭证信息
3. 根据账号类型（AKSK/IAM Role）获取临时凭证
4. 设置环境变量，boto3 自动使用目标账号凭证

---

## 2. 改造范围

### 2.1 改造的 MCP Server
已改造完成：
- `billing-cost-management-mcp-server`

待改造：
- 其他需要多账号访问能力的 MCP Servers（如 CloudWatch、S3 等）

### 2.2 改造层级
```
src/billing-cost-management-mcp-server/
├── entrypoint.py                      # ✅ 新增：统一入口
├── cred_extract_services/             # ✅ 新增：凭证提取服务
│   ├── __init__.py
│   ├── aws_client.py                  # STS AssumeRole
│   ├── context_manager.py             # 环境变量管理
│   ├── credential_extractor.py        # 凭证提取核心
│   ├── crypto.py                      # AKSK 解密
│   ├── database.py                    # 数据库查询
│   └── exceptions.py                  # 自定义异常
├── awslabs/.../tools/                 # ✅ 修改：所有 tool 函数
│   ├── aws_pricing_tools.py
│   ├── budget_tools.py
│   ├── compute_optimizer_tools.py
│   ├── cost_anomaly_tools.py
│   └── ... (其他 tools)
└── awslabs/.../utilities/             # ✅ 修改：工具函数
    └── aws_service_base.py            # create_aws_client 不变
```

---

## 3. 核心改造点

### 3.1 新增凭证提取服务层 (cred_extract_services/)
**目的**：自包含的凭证管理模块，不依赖项目代码

#### 3.1.1 模块职责
| 模块 | 职责 | 依赖 |
|------|------|------|
| `database.py` | 查询 `aws_accounts` 表和 `organizations` 表 | SQLAlchemy, boto3 (Secrets Manager) |
| `crypto.py` | 解密 AKSK 凭证 (Fernet) | cryptography |
| `aws_client.py` | STS AssumeRole 获取临时凭证 | boto3 |
| `credential_extractor.py` | 凭证提取核心逻辑 | 上述模块 |
| `context_manager.py` | 设置环境变量 (boto3 标准变量) | 无 |
| `exceptions.py` | 自定义异常类 | 无 |

#### 3.1.2 数据库查询逻辑
```sql
SELECT
    a.id, a.account_id, a.alias, a.auth_type,
    a.access_key_id, a.secret_access_key_encrypted,
    a.role_arn, a.region, a.org_id,
    o.external_id  -- 从 organizations 表获取
FROM aws_accounts a
LEFT JOIN organizations o ON a.org_id = o.id
WHERE a.account_id = :account_id
```

**关键字段说明**：
- `auth_type`: "aksk" 或 "iam_role"
- `access_key_id`: AKSK 类型，明文存储
- `secret_access_key_encrypted`: AKSK 类型，Fernet 加密
- `role_arn`: IAM Role 类型
- `external_id`: IAM Role 类型，从 organizations 表获取

#### 3.1.3 凭证提取流程
```python
async def extract_aws_credentials(account_id: str) -> dict:
    # 1. 查询数据库
    account = await query_account(account_id)

    # 2. 根据 auth_type 选择分支
    if account["auth_type"] == "aksk":
        # 解密 Secret Access Key
        secret_key = decrypt_aksk(account["encrypted_secret_key"])
        return {
            "access_key_id": account["access_key_id"],  # 明文
            "secret_access_key": secret_key,
            "session_token": None,
            "region": account["region"],
            "account_id": account["account_id"]
        }

    elif account["auth_type"] == "iam_role":
        # AssumeRole 获取临时凭证
        credentials = await assume_role(
            role_arn=account["role_arn"],
            session_name=f"costq-{uuid.uuid4()}",
            external_id=account["external_id"],  # 必须！
            region=account["region"]
        )
        return {
            "access_key_id": credentials["AccessKeyId"],
            "secret_access_key": credentials["SecretAccessKey"],
            "session_token": credentials["SessionToken"],
            "region": account["region"],
            "account_id": account["account_id"]
        }
```

#### 3.1.4 环境变量设置
```python
def set_aws_credentials(
    access_key_id: str,
    secret_access_key: str,
    session_token: Optional[str] = None,
    region: str = "us-east-1",
    account_id: Optional[str] = None
) -> None:
    os.environ["AWS_ACCESS_KEY_ID"] = access_key_id
    os.environ["AWS_SECRET_ACCESS_KEY"] = secret_access_key

    # Session Token 处理：有值则设置，无值则删除
    if session_token:
        os.environ["AWS_SESSION_TOKEN"] = session_token
    elif "AWS_SESSION_TOKEN" in os.environ:
        del os.environ["AWS_SESSION_TOKEN"]

    os.environ["AWS_DEFAULT_REGION"] = region
```

**关键点**：
- boto3 自动识别标准环境变量（AWS_ACCESS_KEY_ID、AWS_SECRET_ACCESS_KEY、AWS_SESSION_TOKEN、AWS_DEFAULT_REGION），无需额外配置
- Session Token 的删除逻辑避免残留（AKSK 模式没有 session token）

---

### 3.2 新增统一入口 (entrypoint.py)

#### 3.2.1 核心函数
```python
async def _setup_account_context(target_account_id: str) -> dict:
    """设置 AWS 凭证上下文

    Args:
        target_account_id: AWS 账号 ID (数据库主键)

    Returns:
        凭证信息字典（已脱敏）

    Raises:
        AccountNotFoundError: 账号不存在
        CredentialDecryptionError: AKSK 解密失败
        AssumeRoleError: IAM Role AssumeRole 失败
        DatabaseConnectionError: 数据库连接失败
    """
    # 1. 提取凭证
    credentials = await extract_aws_credentials(target_account_id)

    # 2. 设置环境变量
    set_aws_credentials(
        access_key_id=credentials["access_key_id"],
        secret_access_key=credentials["secret_access_key"],
        session_token=credentials.get("session_token"),
        region=credentials["region"],
        account_id=credentials["account_id"]
    )

    # 3. 返回脱敏信息
    return {
        "account_id": credentials["account_id"],
        "account_alias": credentials.get("alias", "Unknown"),
        "auth_type": credentials["auth_type"],
        "region": credentials["region"]
    }
```

#### 3.2.2 主函数修改
```python
def main():
    """启动 MCP Server

    环境变量配置：
        FASTMCP_TRANSPORT: 'stdio' | 'streamable-http' (默认)
        FASTMCP_HOST: 默认 '0.0.0.0'
        FASTMCP_PORT: 默认 8000
        FASTMCP_STATELESS_HTTP: 默认 'true'
    """
    from awslabs.billing_cost_management_mcp_server.server import mcp, setup

    transport = os.environ.get("FASTMCP_TRANSPORT", "streamable-http")
    host = os.environ.get("FASTMCP_HOST", "0.0.0.0")
    port = int(os.environ.get("FASTMCP_PORT", "8000"))
    stateless = os.environ.get("FASTMCP_STATELESS_HTTP", "true").lower() == "true"

    asyncio.run(setup())  # 初始化 server

    if transport == "stdio":
        mcp.run(transport=transport)
    else:
        mcp.run(transport=transport, host=host, port=port, stateless_http=stateless)
```

---

### 3.3 修改所有 Tool 函数

#### 3.3.1 参数修改模式
**所有 tool 函数都新增参数**：
```python
@server.tool(name="tool-name", description="...")
async def tool_function(
    ctx: Context,
    target_account_id: Optional[str] = None,  # ✅ 新增参数
    # ... 其他业务参数
) -> Dict[str, Any]:
```

#### 3.3.2 标准改造模板
```python
async def tool_function(
    ctx: Context,
    target_account_id: Optional[str] = None,
    # ... 业务参数
) -> Dict[str, Any]:
    try:
        # ===== 账号上下文初始化 =====
        if target_account_id:
            from entrypoint import _setup_account_context
            await _setup_account_context(target_account_id)

        # ===== 原有逻辑（完全不变）=====
        # ... 业务代码

    # ===== 异常处理 =====
    except AccountNotFoundError:
        return format_response('error', {'error_type': 'account_not_found'},
                               'Account not found. Please check the account ID.')
    except CredentialDecryptionError:
        return format_response('error', {'error_type': 'credential_error'},
                               'Failed to decrypt credentials. Please contact administrator.')
    except AssumeRoleError:
        return format_response('error', {'error_type': 'assume_role_error'},
                               'Failed to assume role. Please check IAM role configuration.')
    except DatabaseConnectionError:
        return format_response('error', {'error_type': 'database_error'},
                               'Database connection failed. Please try again later.')
    except Exception as e:
        return await handle_aws_error(ctx, e, 'operation', 'Service Name')
```

#### 3.3.3 异常处理
**导入自定义异常**：
```python
from entrypoint import (
    AccountNotFoundError,
    CredentialDecryptionError,
    AssumeRoleError,
    DatabaseConnectionError,
)
```

**统一错误返回格式**：
```python
{
    "status": "error",
    "data": {
        "error_type": "account_not_found" | "credential_error" | "assume_role_error" | "database_error"
    },
    "message": "User-friendly error message"
}
```

---

### 3.4 工具函数保持不变

#### 3.4.1 aws_service_base.py
```python
def create_aws_client(service_name: str, region_name: Optional[str] = None) -> Any:
    """创建 AWS 客户端（逻辑完全不变）

    boto3 会自动从环境变量读取凭证：
    - AWS_ACCESS_KEY_ID
    - AWS_SECRET_ACCESS_KEY
    - AWS_SESSION_TOKEN (可选)
    - AWS_DEFAULT_REGION
    """
    # ... 原有逻辑不变
    session = boto3.Session(region_name=region)
    return session.client(service_name, config=config)
```

**关键点**：
- 不需要修改任何 `create_aws_client` 调用
- boto3 自动从环境变量读取凭证
- **零侵入性原则**：业务代码无感知

---

## 4. 改造原则总结

### 4.1 零侵入性原则
✅ **仅修改目标代码，不改变业务逻辑和函数签名**

- Tool 函数新增可选参数 `target_account_id`
- 业务逻辑完全不变
- 工具函数（`create_aws_client`）不变

### 4.2 自包含原则
✅ **凭证提取服务完全独立**

- `cred_extract_services/` 不依赖项目代码
- 可以单独测试、复用

### 4.3 安全原则
✅ **日志安全**

- 不记录任何敏感信息（密码、密钥、凭证、连接串）
- 仅记录操作结果和元数据

✅ **异常安全**

- 统一的自定义异常类型
- 清晰的错误提示

### 4.4 环境变量原则
✅ **标准化**

- 使用 boto3 标准环境变量
- 不自定义 boto3 配置

✅ **生命周期管理**

- Session Token 有值则设置，无值则删除
- 避免环境变量残留

---

## 5. 数据库设计

### 5.1 表结构
```sql
-- AWS 账号表
CREATE TABLE aws_accounts (
    id UUID PRIMARY KEY,
    account_id VARCHAR(12) UNIQUE NOT NULL,  -- AWS 账号 ID
    alias VARCHAR(255),                      -- 账号别名
    auth_type VARCHAR(20) NOT NULL,          -- 'aksk' | 'iam_role'

    -- AKSK 类型字段
    access_key_id VARCHAR(255),              -- 明文
    secret_access_key_encrypted TEXT,        -- Fernet 加密

    -- IAM Role 类型字段
    role_arn TEXT,                           -- IAM Role ARN

    -- 公共字段
    region VARCHAR(50) DEFAULT 'us-east-1',
    org_id UUID,                             -- 组织 ID（外键）

    FOREIGN KEY (org_id) REFERENCES organizations(id)
);

-- 组织表
CREATE TABLE organizations (
    id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    external_id VARCHAR(255) UNIQUE NOT NULL  -- AssumeRole 使用
);
```

### 5.2 数据库连接配置
**环境变量优先级**：
1. `DATABASE_URL`：直接连接串（开发环境）
2. `RDS_SECRET_NAME`：Secrets Manager 密钥名（生产环境）

**Secrets Manager 格式**：
```json
{
    "username": "postgres",
    "password": "xxx",
    "host": "xxx.rds.amazonaws.com",
    "port": 5432,
    "database": "costq"  // 或 "dbname": "costq" (兼容)
}
```

---

## 6. 环境变量配置

### 6.1 必需环境变量
```bash
# 数据库连接
RDS_SECRET_NAME=xxxx

# AKSK 加密密钥（Fernet，Base64 编码）
ENCRYPTION_KEY=xxxx

# AWS 区域
AWS_REGION=xxxx

# MCP Server 传输配置
FASTMCP_TRANSPORT=streamable-http    # 或 stdio
FASTMCP_HOST=0.0.0.0
FASTMCP_PORT=8000
FASTMCP_STATELESS_HTTP=true
```

### 6.2 运行时环境变量（自动设置）
```bash
# boto3 自动识别的标准环境变量
AWS_ACCESS_KEY_ID=xxxx
AWS_SECRET_ACCESS_KEY=xxxx
AWS_SESSION_TOKEN=xxxx  # 临时凭证
AWS_DEFAULT_REGION=xxxx
```

---

## 7. 改造验证清单

### 7.1 功能验证
- [ ] AKSK 账号凭证提取正常
- [ ] IAM Role 账号凭证提取正常
- [ ] External ID 正确传递
- [ ] Session Token 正确处理（有/无）
- [ ] 多账号切换正常
- [ ] 默认凭证（无 target_account_id）正常

### 7.2 异常处理验证
- [ ] 账号不存在 → AccountNotFoundError
- [ ] AKSK 解密失败 → CredentialDecryptionError
- [ ] AssumeRole 失败 → AssumeRoleError
- [ ] 数据库连接失败 → DatabaseConnectionError

### 7.3 安全验证
- [ ] 日志不包含任何凭证信息
- [ ] 错误消息不泄露敏感信息
- [ ] External ID 正确验证

---

## 8. 后续优化方向

### 8.1 缓存机制
- 临时凭证缓存（避免频繁 AssumeRole）
- 账号信息缓存（减少数据库查询）

### 8.2 并发优化
- 异步数据库查询池
- 连接池管理

### 8.3 监控告警
- 凭证过期监控
- AssumeRole 失败率监控
- 数据库查询性能监控
