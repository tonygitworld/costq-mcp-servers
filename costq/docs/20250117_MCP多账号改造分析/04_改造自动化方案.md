# MCP Server æ”¹é€ è‡ªåŠ¨åŒ–æ–¹æ¡ˆ

> æœ¬æ–‡æ¡£æä¾›å®Œæ•´çš„ Skill è‡ªåŠ¨åŒ–å®ç°æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ä»£ç ã€æµ‹è¯•å’Œéƒ¨ç½²

---

## 1. è‡ªåŠ¨åŒ–æ¶æ„

### 1.1 æ ¸å¿ƒç»„ä»¶
```
skills/
â”œâ”€â”€ mcp_migration/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ skill.py              # Skill ä¸»é€»è¾‘
â”‚   â”œâ”€â”€ file_operations.py    # æ–‡ä»¶æ“ä½œ
â”‚   â”œâ”€â”€ code_modifier.py      # ä»£ç ä¿®æ”¹
â”‚   â”œâ”€â”€ validators.py         # éªŒè¯å™¨
â”‚   â””â”€â”€ templates/            # ä»£ç æ¨¡æ¿
â”‚       â”œâ”€â”€ entrypoint.py.j2
â”‚       â”œâ”€â”€ tool_wrapper.py.j2
â”‚       â””â”€â”€ exception_handler.py.j2
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_skill.py
â”‚   â”œâ”€â”€ test_file_operations.py
â”‚   â””â”€â”€ test_code_modifier.py
â””â”€â”€ README.md
```

### 1.2 æ‰§è¡Œæµç¨‹
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è¾“å…¥å‚æ•°       â”‚  (MCP Server è·¯å¾„)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  éªŒè¯å‰ç½®æ¡ä»¶   â”‚  (æ£€æŸ¥ç›®å½•ã€Git çŠ¶æ€)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å¤åˆ¶æœåŠ¡å±‚     â”‚  (cred_extract_services)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”Ÿæˆå…¥å£æ–‡ä»¶   â”‚  (entrypoint.py)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¿®æ”¹ Tools     â”‚  (æ‰¹é‡æ·»åŠ è´¦å·ä¸Šä¸‹æ–‡)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è¿è¡Œæµ‹è¯•       â”‚  (pytest)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”ŸæˆæŠ¥å‘Š       â”‚  (MIGRATION_REPORT.md)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Skill å®ç°

### 2.1 ä¸» Skill ç±»
```python
# skills/mcp_migration/skill.py
import asyncio
import logging
from pathlib import Path
from typing import Dict, Any, List
from datetime import datetime

from .file_operations import FileOperations
from .code_modifier import CodeModifier
from .validators import Validator

logger = logging.getLogger(__name__)


class MCPMigrationSkill:
    """MCP Server å¤šè´¦å·æ”¹é€ è‡ªåŠ¨åŒ– Skill

    åŠŸèƒ½ï¼š
    1. éªŒè¯å‰ç½®æ¡ä»¶
    2. å¤åˆ¶å‡­è¯æå–æœåŠ¡å±‚
    3. ç”Ÿæˆ entrypoint.py
    4. æ‰¹é‡ä¿®æ”¹ tool å‡½æ•°
    5. è¿è¡Œæµ‹è¯•éªŒè¯
    6. ç”Ÿæˆæ”¹é€ æŠ¥å‘Š
    """

    def __init__(
        self,
        target_path: Path,
        reference_path: Path = None,
        dry_run: bool = False,
        skip_tests: bool = False
    ):
        self.target_path = Path(target_path).resolve()
        self.reference_path = reference_path or Path(
            "src/billing-cost-management-mcp-server"
        ).resolve()
        self.dry_run = dry_run
        self.skip_tests = skip_tests

        self.file_ops = FileOperations(self.target_path, dry_run=dry_run)
        self.code_modifier = CodeModifier()
        self.validator = Validator()

        self.results = {
            "start_time": datetime.now(),
            "steps_completed": [],
            "modified_files": [],
            "errors": [],
            "warnings": [],
            "test_results": None
        }

    async def execute(self) -> Dict[str, Any]:
        """æ‰§è¡Œæ”¹é€ æµç¨‹

        Returns:
            æ”¹é€ ç»“æœå­—å…¸
        """
        try:
            logger.info(f"ğŸš€ Starting MCP Migration for: {self.target_path}")

            # Step 0: éªŒè¯å‰ç½®æ¡ä»¶
            if not await self._validate_preconditions():
                self.results["status"] = "failed"
                self.results["message"] = "Precondition validation failed"
                return self.results

            # Step 1: å¤åˆ¶å‡­è¯æå–æœåŠ¡
            await self._copy_credential_services()

            # Step 2: åˆ›å»º entrypoint.py
            await self._create_entrypoint()

            # Step 3: ä¿®æ”¹ tool å‡½æ•°
            await self._modify_all_tools()

            # Step 4: æ›´æ–°ä¾èµ–
            await self._update_dependencies()

            # Step 5: è¿è¡Œæµ‹è¯•ï¼ˆå¯é€‰ï¼‰
            if not self.skip_tests:
                await self._run_tests()

            # Step 6: ç”ŸæˆæŠ¥å‘Š
            await self._generate_report()

            self.results["status"] = "success"
            self.results["end_time"] = datetime.now()
            self.results["duration"] = (
                self.results["end_time"] - self.results["start_time"]
            ).total_seconds()

            logger.info(f"âœ… Migration completed in {self.results['duration']:.1f}s")

        except Exception as e:
            logger.error(f"âŒ Migration failed: {e}", exc_info=True)
            self.results["status"] = "failed"
            self.results["errors"].append(str(e))

        return self.results

    async def _validate_preconditions(self) -> bool:
        """éªŒè¯å‰ç½®æ¡ä»¶"""
        logger.info("Step 0: Validating preconditions")

        # 1. æ£€æŸ¥ç›®æ ‡è·¯å¾„å­˜åœ¨
        if not self.target_path.exists():
            self.results["errors"].append(f"Target path not found: {self.target_path}")
            return False

        # 2. æ£€æŸ¥æ˜¯å¦æ˜¯ MCP Server
        if not self.validator.is_mcp_server(self.target_path):
            self.results["errors"].append("Not a valid MCP server directory")
            return False

        # 3. æ£€æŸ¥æ˜¯å¦å·²æ”¹é€ 
        if self.validator.is_already_migrated(self.target_path):
            self.results["warnings"].append("Server appears to be already migrated")
            # ç»§ç»­æ‰§è¡Œï¼Œå¯èƒ½æ˜¯å¢é‡æ›´æ–°

        # 4. æ£€æŸ¥ Git çŠ¶æ€ï¼ˆå¯é€‰ï¼‰
        if self.validator.has_uncommitted_changes(self.target_path):
            self.results["warnings"].append(
                "Working directory has uncommitted changes. "
                "Consider committing or stashing before migration."
            )

        # 5. æ£€æŸ¥å‚è€ƒé¡¹ç›®
        if not self.reference_path.exists():
            self.results["errors"].append(f"Reference path not found: {self.reference_path}")
            return False

        self.results["steps_completed"].append("precondition_validation")
        return len(self.results["errors"]) == 0

    async def _copy_credential_services(self):
        """å¤åˆ¶å‡­è¯æå–æœåŠ¡å±‚"""
        logger.info("Step 1: Copying credential services")

        source = self.reference_path / "cred_extract_services"
        target = self.target_path / "cred_extract_services"

        if target.exists():
            logger.warning(f"Target already exists: {target}, skipping copy")
            self.results["warnings"].append("cred_extract_services already exists")
        else:
            await self.file_ops.copy_directory(source, target)
            logger.info(f"âœ… Copied credential services to {target}")

        self.results["steps_completed"].append("credential_services_copied")

    async def _create_entrypoint(self):
        """åˆ›å»º entrypoint.py"""
        logger.info("Step 2: Creating entrypoint.py")

        target_file = self.target_path / "entrypoint.py"

        if target_file.exists():
            logger.warning(f"Target already exists: {target_file}, backing up")
            await self.file_ops.backup_file(target_file)

        # ä»æ¨¡æ¿ç”Ÿæˆ
        package_name = self._get_package_name()
        content = await self.file_ops.render_template(
            "entrypoint.py.j2",
            package_name=package_name
        )

        await self.file_ops.write_file(target_file, content)
        logger.info(f"âœ… Created entrypoint.py")

        self.results["steps_completed"].append("entrypoint_created")
        self.results["modified_files"].append(str(target_file))

    async def _modify_all_tools(self):
        """ä¿®æ”¹æ‰€æœ‰ tool å‡½æ•°"""
        logger.info("Step 3: Modifying tool functions")

        tools_dir = self._get_tools_directory()
        if not tools_dir:
            self.results["errors"].append("Tools directory not found")
            return

        tool_files = list(tools_dir.glob("*_tools.py"))
        logger.info(f"Found {len(tool_files)} tool files")

        for tool_file in tool_files:
            try:
                modified = await self._modify_tool_file(tool_file)
                if modified:
                    self.results["modified_files"].append(str(tool_file))
                    logger.info(f"âœ… Modified {tool_file.name}")
            except Exception as e:
                logger.error(f"Failed to modify {tool_file.name}: {e}")
                self.results["errors"].append(f"{tool_file.name}: {str(e)}")

        self.results["steps_completed"].append(f"modified_{len(self.results['modified_files'])}_tools")

    async def _modify_tool_file(self, file_path: Path) -> bool:
        """ä¿®æ”¹å•ä¸ª tool æ–‡ä»¶

        Returns:
            æ˜¯å¦æˆåŠŸä¿®æ”¹
        """
        original_content = file_path.read_text()

        # å¤‡ä»½åŸæ–‡ä»¶
        await self.file_ops.backup_file(file_path)

        # åº”ç”¨ä¿®æ”¹
        modified_content = original_content

        # 1. æ·»åŠ å¯¼å…¥
        modified_content = self.code_modifier.add_imports(modified_content)

        # 2. ä¿®æ”¹å‡½æ•°ç­¾å
        modified_content = self.code_modifier.add_account_id_param(modified_content)

        # 3. æ·»åŠ è´¦å·ä¸Šä¸‹æ–‡åˆå§‹åŒ–
        modified_content = self.code_modifier.add_context_initialization(modified_content)

        # 4. æ·»åŠ å¼‚å¸¸å¤„ç†
        modified_content = self.code_modifier.add_exception_handling(modified_content)

        # æ£€æŸ¥æ˜¯å¦æœ‰ä¿®æ”¹
        if modified_content == original_content:
            logger.warning(f"No changes made to {file_path.name}")
            return False

        # å†™å…¥ä¿®æ”¹
        await self.file_ops.write_file(file_path, modified_content)
        return True

    async def _update_dependencies(self):
        """æ›´æ–°ä¾èµ–"""
        logger.info("Step 4: Updating dependencies")

        pyproject = self.target_path / "pyproject.toml"
        if not pyproject.exists():
            logger.warning("pyproject.toml not found, skipping dependency update")
            return

        # æ·»åŠ æ–°ä¾èµ–
        required_deps = [
            "sqlalchemy>=2.0.0",
            "psycopg2-binary>=2.9.0",
            "cryptography>=41.0.0"
        ]

        await self.file_ops.add_dependencies(pyproject, required_deps)

        self.results["steps_completed"].append("dependencies_updated")

    async def _run_tests(self):
        """è¿è¡Œæµ‹è¯•"""
        logger.info("Step 5: Running tests")

        import subprocess

        test_dir = self.target_path / "tests"
        if not test_dir.exists():
            logger.warning("Tests directory not found, skipping tests")
            return

        result = subprocess.run(
            ["pytest", "-v", str(test_dir)],
            capture_output=True,
            text=True,
            cwd=self.target_path
        )

        self.results["test_results"] = {
            "returncode": result.returncode,
            "passed": result.returncode == 0,
            "stdout": result.stdout,
            "stderr": result.stderr
        }

        if result.returncode == 0:
            logger.info("âœ… All tests passed")
        else:
            logger.error("âŒ Tests failed")
            self.results["errors"].append("Test execution failed")

        self.results["steps_completed"].append("tests_executed")

    async def _generate_report(self):
        """ç”Ÿæˆæ”¹é€ æŠ¥å‘Š"""
        logger.info("Step 6: Generating migration report")

        report_path = self.target_path / "MIGRATION_REPORT.md"

        report = f"""# MCP Server å¤šè´¦å·æ”¹é€ æŠ¥å‘Š

## åŸºæœ¬ä¿¡æ¯
- **æ”¹é€ æ—¥æœŸ**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- **ç›®æ ‡è·¯å¾„**: `{self.target_path}`
- **æ‰§è¡Œæ¨¡å¼**: {'DRY RUN' if self.dry_run else 'NORMAL'}
- **æ‰§è¡Œæ—¶é•¿**: {self.results.get('duration', 0):.1f} ç§’

## æ”¹é€ çŠ¶æ€
**çŠ¶æ€**: {self.results['status'].upper()} {'âœ…' if self.results['status'] == 'success' else 'âŒ'}

## å®Œæˆæ­¥éª¤
{chr(10).join(f'- âœ… {step}' for step in self.results["steps_completed"])}

## ä¿®æ”¹æ–‡ä»¶
{chr(10).join(f'- `{file}`' for file in self.results["modified_files"]) or 'æ— '}

## æµ‹è¯•ç»“æœ
"""

        if self.results["test_results"]:
            test_status = "âœ… PASSED" if self.results["test_results"]["passed"] else "âŒ FAILED"
            report += f"""
- **çŠ¶æ€**: {test_status}
- **é€€å‡ºç **: {self.results["test_results"]["returncode"]}

### æµ‹è¯•è¾“å‡º
```
{self.results["test_results"]["stdout"][:1000]}
```
"""
        else:
            report += "æœªæ‰§è¡Œæµ‹è¯•\n"

        report += f"""
## é”™è¯¯å’Œè­¦å‘Š

### é”™è¯¯ ({len(self.results["errors"])})
{chr(10).join(f'- âŒ {error}' for error in self.results["errors"]) or 'æ— '}

### è­¦å‘Š ({len(self.results["warnings"])})
{chr(10).join(f'- âš ï¸ {warning}' for warning in self.results["warnings"]) or 'æ— '}

## ä¸‹ä¸€æ­¥è¡ŒåŠ¨

### å¿…é¡»æ‰§è¡Œ
1. **äººå·¥å®¡æŸ¥æ‰€æœ‰ä¿®æ”¹çš„æ–‡ä»¶**
   ```bash
   git diff
   ```

2. **è¿è¡Œå®Œæ•´æµ‹è¯•**
   ```bash
   pytest tests/ -v
   ```

3. **éªŒè¯åŠŸèƒ½**
   - [ ] AKSK è´¦å·å‡­è¯æ­£å¸¸
   - [ ] IAM Role è´¦å·å‡­è¯æ­£å¸¸
   - [ ] å¤šè´¦å·åˆ‡æ¢æ­£å¸¸
   - [ ] å¼‚å¸¸å¤„ç†æ­£ç¡®

### å¯é€‰æ‰§è¡Œ
4. **æ›´æ–°æ–‡æ¡£**
   - [ ] README.md
   - [ ] API æ–‡æ¡£

5. **æäº¤ä»£ç **
   ```bash
   git add .
   git commit -m "feat: add multi-account support"
   git push
   ```

## å›æ»šæ–¹æ³•
å¦‚æœæ”¹é€ æœ‰é—®é¢˜ï¼Œå¯ä»¥å›æ»šï¼š
```bash
# æ¢å¤å¤‡ä»½æ–‡ä»¶
find . -name "*.backup" | while read f; do
  mv "$f" "${{f%.backup}}"
done

# æˆ–ä½¿ç”¨ Git å›æ»š
git checkout .
```

---
*æŠ¥å‘Šç”± MCPMigrationSkill è‡ªåŠ¨ç”Ÿæˆ*
"""

        await self.file_ops.write_file(report_path, report)
        logger.info(f"âœ… Generated migration report: {report_path}")

        self.results["report_path"] = str(report_path)

    def _get_package_name(self) -> str:
        """è·å–åŒ…å"""
        # ä» pyproject.toml è¯»å–
        pyproject = self.target_path / "pyproject.toml"
        if pyproject.exists():
            try:
                import tomli
                with open(pyproject, 'rb') as f:
                    config = tomli.load(f)
                    name = config["project"]["name"]
                    return name.replace("-", "_")
            except Exception as e:
                logger.warning(f"Failed to read pyproject.toml: {e}")

        # å›é€€ï¼šä»ç›®å½•åæ¨æ–­
        return self.target_path.name.replace("-", "_")

    def _get_tools_directory(self) -> Path:
        """è·å– tools ç›®å½•"""
        package_name = self._get_package_name()

        # å°è¯•å‡ ç§å¯èƒ½çš„è·¯å¾„
        possible_paths = [
            self.target_path / "awslabs" / package_name / "tools",
            self.target_path / package_name / "tools",
            self.target_path / "tools"
        ]

        for path in possible_paths:
            if path.exists() and path.is_dir():
                return path

        return None
```

---

### 2.2 æ–‡ä»¶æ“ä½œæ¨¡å—
```python
# skills/mcp_migration/file_operations.py
import shutil
from pathlib import Path
from typing import List
from jinja2 import Environment, FileSystemLoader
import logging

logger = logging.getLogger(__name__)


class FileOperations:
    """æ–‡ä»¶æ“ä½œå·¥å…·ç±»"""

    def __init__(self, base_path: Path, dry_run: bool = False):
        self.base_path = base_path
        self.dry_run = dry_run

        # Jinja2 æ¨¡æ¿ç¯å¢ƒ
        template_dir = Path(__file__).parent / "templates"
        self.jinja_env = Environment(loader=FileSystemLoader(str(template_dir)))

    async def copy_directory(self, source: Path, target: Path):
        """å¤åˆ¶ç›®å½•"""
        if self.dry_run:
            logger.info(f"[DRY RUN] Would copy {source} to {target}")
            return

        shutil.copytree(source, target)

    async def backup_file(self, file_path: Path):
        """å¤‡ä»½æ–‡ä»¶"""
        backup_path = file_path.with_suffix(file_path.suffix + ".backup")

        if self.dry_run:
            logger.info(f"[DRY RUN] Would backup {file_path} to {backup_path}")
            return

        shutil.copy2(file_path, backup_path)

    async def write_file(self, file_path: Path, content: str):
        """å†™å…¥æ–‡ä»¶"""
        if self.dry_run:
            logger.info(f"[DRY RUN] Would write to {file_path}")
            logger.debug(f"Content preview: {content[:200]}...")
            return

        file_path.write_text(content, encoding='utf-8')

    async def render_template(self, template_name: str, **kwargs) -> str:
        """æ¸²æŸ“ Jinja2 æ¨¡æ¿"""
        template = self.jinja_env.get_template(template_name)
        return template.render(**kwargs)

    async def add_dependencies(self, pyproject_path: Path, deps: List[str]):
        """æ·»åŠ ä¾èµ–åˆ° pyproject.toml"""
        if self.dry_run:
            logger.info(f"[DRY RUN] Would add dependencies: {deps}")
            return

        try:
            import tomli
            import tomli_w

            with open(pyproject_path, 'rb') as f:
                config = tomli.load(f)

            current_deps = config.get("project", {}).get("dependencies", [])

            for dep in deps:
                dep_name = dep.split(">=")[0].split("==")[0]
                # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
                if not any(dep_name in d for d in current_deps):
                    current_deps.append(dep)
                    logger.info(f"Added dependency: {dep}")

            config["project"]["dependencies"] = current_deps

            with open(pyproject_path, 'wb') as f:
                tomli_w.dump(config, f)

        except Exception as e:
            logger.error(f"Failed to update dependencies: {e}")
```

---

### 2.3 ä»£ç ä¿®æ”¹æ¨¡å—
```python
# skills/mcp_migration/code_modifier.py
import re
import logging

logger = logging.getLogger(__name__)


class CodeModifier:
    """ä»£ç ä¿®æ”¹å·¥å…·ç±»"""

    def add_imports(self, content: str) -> str:
        """æ·»åŠ å¯¼å…¥è¯­å¥"""
        import_block = """
# Import account context exceptions
from entrypoint import (
    AccountNotFoundError,
    CredentialDecryptionError,
    AssumeRoleError,
    DatabaseConnectionError,
)
"""

        if "from entrypoint import" in content:
            logger.debug("Imports already exist, skipping")
            return content

        # åœ¨æœ€åä¸€ä¸ª import åæ’å…¥
        lines = content.split('\n')
        last_import_idx = -1

        for i, line in enumerate(lines):
            if line.startswith(('import ', 'from ')):
                last_import_idx = i

        if last_import_idx >= 0:
            lines.insert(last_import_idx + 1, import_block)
            return '\n'.join(lines)

        # å¦‚æœæ²¡æœ‰æ‰¾åˆ° importï¼Œåœ¨æ–‡ä»¶å¼€å¤´æ’å…¥
        return import_block + "\n" + content

    def add_account_id_param(self, content: str) -> str:
        """æ·»åŠ  target_account_id å‚æ•°"""
        # åŒ¹é… @server.tool è£…é¥°çš„å¼‚æ­¥å‡½æ•°
        pattern = r'(@\w+\.tool\([^)]+\)\s*async def (\w+)\(\s*ctx:\s*Context,)'

        def replacer(match):
            decorator = match.group(0)
            # æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰ target_account_id
            if 'target_account_id' in match.group(0):
                return decorator
            # åœ¨ ctx åæ·»åŠ å‚æ•°
            return decorator + '\n    target_account_id: Optional[str] = None,'

        return re.sub(pattern, replacer, content, flags=re.MULTILINE)

    def add_context_initialization(self, content: str) -> str:
        """æ·»åŠ è´¦å·ä¸Šä¸‹æ–‡åˆå§‹åŒ–ä»£ç """
        init_block = """
        # ===== Account context initialization =====
        if target_account_id:
            from entrypoint import _setup_account_context
            await _setup_account_context(target_account_id)

        # ===== Original logic (unchanged) ====="""

        # åœ¨ try: åæ’å…¥ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
        if "Account context initialization" in content:
            logger.debug("Context initialization already exists")
            return content

        # æ‰¾åˆ° try: åçš„ç¬¬ä¸€è¡Œ
        pattern = r'(\s+try:\s*\n)'
        replacement = r'\1' + init_block + '\n'

        return re.sub(pattern, replacement, content)

    def add_exception_handling(self, content: str) -> str:
        """æ·»åŠ å¼‚å¸¸å¤„ç†"""
        exception_block = """
    # ===== Exception handling =====
    except AccountNotFoundError:
        return format_response('error', {'error_type': 'account_not_found'},
                               'Account not found. Please check the account ID.')
    except CredentialDecryptionError:
        return format_response('error', {'error_type': 'credential_error'},
                               'Failed to decrypt credentials. Please contact administrator.')
    except AssumeRoleError:
        return format_response('error', {'error_type': 'assume_role_error'},
                               'Failed to assume role. Please check IAM role configuration.')
    except DatabaseConnectionError:
        return format_response('error', {'error_type': 'database_error'},
                               'Database connection failed. Please try again later.')
"""

        if "Exception handling" in content:
            logger.debug("Exception handling already exists")
            return content

        # åœ¨æœ€åçš„ except Exception å‰æ’å…¥
        pattern = r'(\s+)(except Exception as \w+:)'
        replacement = exception_block + r'\n\1\2'

        return re.sub(pattern, replacement, content)
```

---

## 3. CLI å·¥å…·

### 3.1 å‘½ä»¤è¡Œæ¥å£
```python
# skills/mcp_migration_cli.py
#!/usr/bin/env python3
"""MCP Migration CLI Tool

Usage:
    python mcp_migration_cli.py <mcp_server_path> [options]

Examples:
    # æ­£å¸¸æ¨¡å¼
    python mcp_migration_cli.py src/new-mcp-server

    # Dry run æ¨¡å¼ï¼ˆä¸å®é™…ä¿®æ”¹æ–‡ä»¶ï¼‰
    python mcp_migration_cli.py src/new-mcp-server --dry-run

    # è·³è¿‡æµ‹è¯•
    python mcp_migration_cli.py src/new-mcp-server --skip-tests

    # æŒ‡å®šå‚è€ƒé¡¹ç›®
    python mcp_migration_cli.py src/new-mcp-server \\
        --reference src/billing-cost-management-mcp-server
"""

import asyncio
import argparse
import logging
import sys
from pathlib import Path

from mcp_migration.skill import MCPMigrationSkill


def setup_logging(verbose: bool = False):
    """é…ç½®æ—¥å¿—"""
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )


async def main():
    parser = argparse.ArgumentParser(
        description='MCP Server Multi-Account Migration Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    parser.add_argument(
        'target_path',
        type=Path,
        help='Path to the MCP server to migrate'
    )

    parser.add_argument(
        '--reference',
        type=Path,
        help='Path to the reference MCP server (default: billing-cost-management-mcp-server)'
    )

    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Preview changes without modifying files'
    )

    parser.add_argument(
        '--skip-tests',
        action='store_true',
        help='Skip running tests after migration'
    )

    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose logging'
    )

    args = parser.parse_args()

    setup_logging(args.verbose)
    logger = logging.getLogger(__name__)

    logger.info(f"ğŸš€ MCP Migration Tool")
    logger.info(f"Target: {args.target_path}")
    logger.info(f"Mode: {'DRY RUN' if args.dry_run else 'NORMAL'}")

    # åˆ›å»ºå¹¶æ‰§è¡Œ Skill
    skill = MCPMigrationSkill(
        target_path=args.target_path,
        reference_path=args.reference,
        dry_run=args.dry_run,
        skip_tests=args.skip_tests
    )

    results = await skill.execute()

    # è¾“å‡ºç»“æœ
    print("\n" + "="*60)
    print(f"Migration Status: {results['status'].upper()}")
    print("="*60)

    if results["steps_completed"]:
        print("\nâœ… Completed Steps:")
        for step in results["steps_completed"]:
            print(f"  - {step}")

    if results["modified_files"]:
        print(f"\nğŸ“ Modified Files ({len(results['modified_files'])}):")
        for file in results["modified_files"]:
            print(f"  - {file}")

    if results["warnings"]:
        print(f"\nâš ï¸  Warnings ({len(results['warnings'])}):")
        for warning in results["warnings"]:
            print(f"  - {warning}")

    if results["errors"]:
        print(f"\nâŒ Errors ({len(results['errors'])}):")
        for error in results["errors"]:
            print(f"  - {error}")

    if results.get("report_path"):
        print(f"\nğŸ“„ Migration Report: {results['report_path']}")

    print(f"\nDuration: {results.get('duration', 0):.1f}s")
    print("="*60)

    # é€€å‡ºç 
    sys.exit(0 if results["status"] == "success" else 1)


if __name__ == "__main__":
    asyncio.run(main())
```

---

## 4. ä½¿ç”¨ç¤ºä¾‹

### 4.1 åŸºæœ¬ä½¿ç”¨
```bash
# 1. æ”¹é€ æ–°çš„ MCP Server
python skills/mcp_migration_cli.py src/cloudwatch-mcp-server

# 2. Dry run æ¨¡å¼ï¼ˆé¢„è§ˆï¼‰
python skills/mcp_migration_cli.py src/cloudwatch-mcp-server --dry-run

# 3. è·³è¿‡æµ‹è¯•ï¼ˆåŠ å¿«é€Ÿåº¦ï¼‰
python skills/mcp_migration_cli.py src/cloudwatch-mcp-server --skip-tests

# 4. è¯¦ç»†è¾“å‡º
python skills/mcp_migration_cli.py src/cloudwatch-mcp-server -v
```

### 4.2 æ‰¹é‡æ”¹é€ 
```bash
# scripts/batch_migrate.sh
#!/bin/bash

MCP_SERVERS=(
    "src/cloudwatch-mcp-server"
    "src/s3-mcp-server"
    "src/lambda-mcp-server"
)

for server in "${MCP_SERVERS[@]}"; do
    echo "Migrating $server..."
    python skills/mcp_migration_cli.py "$server" || {
        echo "Failed to migrate $server"
        exit 1
    }

    echo "Reviewing changes..."
    git diff "$server"

    read -p "Commit changes? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        git add "$server"
        git commit -m "feat($server): add multi-account support"
    fi
done

echo "All migrations complete!"
```

---

## 5. CI/CD é›†æˆ

### 5.1 GitHub Actions
```yaml
# .github/workflows/mcp-migration.yml
name: MCP Multi-Account Migration

on:
  workflow_dispatch:
    inputs:
      mcp_server_path:
        description: 'MCP Server Path (e.g., src/cloudwatch-mcp-server)'
        required: true
        type: string
      dry_run:
        description: 'Dry Run Mode'
        required: false
        type: boolean
        default: true

jobs:
  migrate:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -r skills/requirements.txt

      - name: Run Migration
        run: |
          python skills/mcp_migration_cli.py \\
            ${{ github.event.inputs.mcp_server_path }} \\
            ${{ github.event.inputs.dry_run && '--dry-run' || '' }} \\
            -v

      - name: Run Tests
        if: ${{ !github.event.inputs.dry_run }}
        run: |
          cd ${{ github.event.inputs.mcp_server_path }}
          pytest tests/ -v

      - name: Upload Migration Report
        uses: actions/upload-artifact@v3
        with:
          name: migration-report
          path: ${{ github.event.inputs.mcp_server_path }}/MIGRATION_REPORT.md

      - name: Create Pull Request
        if: ${{ !github.event.inputs.dry_run }}
        uses: peter-evans/create-pull-request@v5
        with:
          commit-message: "feat: add multi-account support to ${{ github.event.inputs.mcp_server_path }}"
          title: "[Auto] MCP Migration: ${{ github.event.inputs.mcp_server_path }}"
          body: |
            ## è‡ªåŠ¨æ”¹é€ æŠ¥å‘Š

            - **Skill**: mcp_account_context_migration
            - **Target**: ${{ github.event.inputs.mcp_server_path }}
            - **Workflow Run**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            ### æ”¹é€ å†…å®¹
            - âœ… å¤åˆ¶å‡­è¯æå–æœåŠ¡å±‚
            - âœ… åˆ›å»º entrypoint.py
            - âœ… ä¿®æ”¹æ‰€æœ‰ tool å‡½æ•°
            - âœ… æ›´æ–°ä¾èµ–
            - âœ… è¿è¡Œæµ‹è¯•éªŒè¯

            ### ä¸‹ä¸€æ­¥
            - [ ] äººå·¥å®¡æŸ¥æ‰€æœ‰ä¿®æ”¹
            - [ ] éªŒè¯åŠŸèƒ½æ­£ç¡®æ€§
            - [ ] åˆå¹¶ PR

            è¯¦ç»†æŠ¥å‘Šè§é™„ä»¶ã€‚
          branch: feature/mcp-migration-${{ github.run_number }}
```

---

## 6. æ€»ç»“

### 6.1 æŠ•èµ„æ”¶ç›Š
| é¡¹ç›® | äººå·¥æ”¹é€  | è‡ªåŠ¨åŒ–æ”¹é€  | èŠ‚çœ |
|------|---------|-----------|------|
| å•ä¸ª MCP Server | 4 å°æ—¶ | 10 åˆ†é’Ÿ | ~95% |
| 10 ä¸ª MCP Servers | 40 å°æ—¶ | 2 å°æ—¶ | ~95% |
| é”™è¯¯ç‡ | ~20% | <5% | ~75% |

### 6.2 é€‚ç”¨åœºæ™¯
âœ… æ¨èä½¿ç”¨ï¼š
- æ‰¹é‡æ”¹é€ å¤šä¸ª MCP Server
- æ ‡å‡†åŒ–æ”¹é€ æµç¨‹
- CI/CD è‡ªåŠ¨åŒ–

âš ï¸ è°¨æ…ä½¿ç”¨ï¼š
- éæ ‡å‡†ç»“æ„çš„ MCP Serverï¼ˆéœ€è¦äººå·¥è°ƒæ•´ï¼‰
- å¤æ‚çš„ä¸šåŠ¡é€»è¾‘ï¼ˆå¯èƒ½éœ€è¦ç‰¹æ®Šå¤„ç†ï¼‰

### 6.3 åç»­ä¼˜åŒ–
- [ ] å¢åŠ æ›´å¤šä»£ç æ¨¡å¼è¯†åˆ«
- [ ] æ”¯æŒè‡ªå®šä¹‰æ¨¡æ¿
- [ ] é›†æˆä»£ç è´¨é‡æ£€æŸ¥ï¼ˆlinterï¼‰
- [ ] æ”¯æŒå¢é‡æ›´æ–°ï¼ˆdiff-basedï¼‰
- [ ] æä¾› Web UI
