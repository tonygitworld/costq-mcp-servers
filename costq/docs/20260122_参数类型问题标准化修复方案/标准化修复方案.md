# MCP Server å‚æ•°ç±»å‹é—®é¢˜ - æ ‡å‡†åŒ–ä¿®å¤æ–¹æ¡ˆ

**ç‰ˆæœ¬**: 1.0
**æ—¥æœŸ**: 2026-01-22
**é€‚ç”¨èŒƒå›´**: æ‰€æœ‰é€šè¿‡ AgentCore Gateway éƒ¨ç½²çš„ MCP Server

---

## ğŸ“‹ é—®é¢˜æ€»ç»“

### é—®é¢˜åˆ†ç±»

é€šè¿‡å¯¹ **RISP MCP**ã€**CloudTrail MCP** å’Œ **Billing MCP** ä¸‰ä¸ªé¡¹ç›®çš„åˆ†æï¼Œå‚æ•°ç±»å‹é—®é¢˜å¯å½’çº³ä¸ºä¸¤å¤§ç±»ï¼š

#### ç±»å‹A: å¤æ‚å¯¹è±¡å‚æ•° (dict/list)

**å…¸å‹æ¡ˆä¾‹**: RISP MCP çš„ `filter_expression` å‚æ•°

**é—®é¢˜ç°è±¡**:
```
Error: 1 validation error for get_savings_plans_coverage
Arguments\nfilter_expression\n
Input should be a valid string [type=string_type, input_value={'Dimensions': {...}}, input_type=dict]
```

**æ ¹æœ¬åŸå› **:
1. **FastMCP Schema ç”Ÿæˆç¼ºé™·**: `dict` ç±»å‹æ— æ³•ç”Ÿæˆæ­£ç¡®çš„ `type: object` Schema
2. **Gateway åºåˆ—åŒ–è¡Œä¸ºä¸ç¡®å®š**: å½“ Schema ä¸å®Œæ•´æ—¶ï¼ŒGateway å¯èƒ½ä¸åºåˆ—åŒ–å¯¹è±¡
3. **Pydantic éªŒè¯æ‹¦æˆª**: å‡½æ•°ç­¾åå®šä¹‰ä¸º `str`ï¼Œä½†æ¥æ”¶åˆ° `dict` å¯¼è‡´ ValidationError

**å—å½±å“çš„å‚æ•°ç±»å‹**:
- `filter_expression: Optional[dict]`
- `tags: Optional[List[dict]]`
- ä»»ä½•åµŒå¥—çš„å¤æ‚å¯¹è±¡å‚æ•°

---

#### ç±»å‹B: åŸºç¡€ç±»å‹å‚æ•° (int/float)

**å…¸å‹æ¡ˆä¾‹**: Billing MCP çš„ `max_results` å‚æ•°

**é—®é¢˜ç°è±¡**:
```
JsonSchemaException - Parameter validation failed
Field 'max_results' has invalid type: $.max_results: string found, integer expected
```

**æ ¹æœ¬åŸå› **:
1. **FastMCP Schema ç”Ÿæˆé—®é¢˜**: `int` ç±»å‹å¯èƒ½ç”Ÿæˆä¸å®Œæ•´çš„ Schema
2. **Gateway åºåˆ—åŒ–è¡Œä¸º**: å½“ Schema ä¸æ˜ç¡®æ—¶ï¼ŒGateway å¯èƒ½å°†æ•´æ•°åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²
3. **Pydantic éªŒè¯æ‹¦æˆª**: å‡½æ•°ç­¾åå®šä¹‰ä¸º `int`ï¼Œä½†æ¥æ”¶åˆ° `str` å¯¼è‡´ ValidationError

**å—å½±å“çš„å‚æ•°ç±»å‹**:
- `max_results: Optional[int]`
- `limit: Optional[int]`
- `page_size: Optional[int]`
- `timeout: Optional[int]`
- ä»»ä½•æ•´æ•°ç±»å‹çš„å¯é€‰å‚æ•°

---

### å…±æ€§åˆ†æ

| ç»´åº¦ | ç±»å‹A (dict/list) | ç±»å‹B (int/float) | å…±æ€§ |
|------|------------------|------------------|------|
| **Schema ç”Ÿæˆ** | âŒ æ— æ³•ç”Ÿæˆ `type: object` | âš ï¸ å¯èƒ½ç”Ÿæˆä¸å®Œæ•´ Schema | âœ… FastMCP æ¡†æ¶é—®é¢˜ |
| **Gateway è¡Œä¸º** | ä¸åºåˆ—åŒ–,ä¼ é€’åŸå§‹ dict | å¯èƒ½åºåˆ—åŒ–ä¸º string | âœ… è¡Œä¸ºä¸ç¡®å®š |
| **Pydantic éªŒè¯** | æœŸæœ› str,æ¥æ”¶ dict â†’ å¤±è´¥ | æœŸæœ› int,æ¥æ”¶ str â†’ å¤±è´¥ | âœ… ç±»å‹ä¸åŒ¹é… |
| **ä¿®å¤æ–¹æ¡ˆ** | Union[str, dict] | Union[str, int] | âœ… Union ç±»å‹ + æ™ºèƒ½è½¬æ¢ |
| **è§£æé€»è¾‘** | isinstance() æ£€æµ‹ | isinstance() æ£€æµ‹ | âœ… è¿è¡Œæ—¶ç±»å‹æ£€æµ‹ |

---

## ğŸ¯ æ ‡å‡†åŒ–ä¿®å¤æ–¹æ¡ˆ

### æ ¸å¿ƒåŸåˆ™

#### 1. **å‚æ•°ç±»å‹å£°æ˜ - Union æ¨¡å¼**

**è§„åˆ™**: æ‰€æœ‰å¯èƒ½å— Gateway åºåˆ—åŒ–å½±å“çš„å‚æ•°ï¼Œéƒ½ä½¿ç”¨ `Union` ç±»å‹

```python
from typing import Union, Optional

# âœ… å¤æ‚å¯¹è±¡å‚æ•°
filter_expression: Optional[Union[str, dict]] = None
tags: Optional[Union[str, List[dict]]] = None

# âœ… åŸºç¡€ç±»å‹å‚æ•°
max_results: Optional[Union[str, int]] = None
limit: Optional[Union[str, int]] = None
timeout: Optional[Union[str, float]] = None
```

**ä¸ºä»€ä¹ˆä½¿ç”¨ Union?**
- âœ… æ”¾å®½ Pydantic ç±»å‹éªŒè¯ï¼Œå…è®¸å¤šç§ç±»å‹é€šè¿‡
- âœ… ä¸ä¾èµ–ä¸Šæ¸¸ Gateway çš„åºåˆ—åŒ–è¡Œä¸º
- âœ… å‘åå…¼å®¹ï¼Œæ”¯æŒæ–°æ—§ä¸¤ç§è°ƒç”¨æ–¹å¼

---

#### 2. **æ™ºèƒ½è§£æå‡½æ•° - é€šç”¨æ¨¡æ¿**

**è§„åˆ™**: æå–å…¬å…±çš„ç±»å‹è½¬æ¢é€»è¾‘ï¼Œå‡å°‘é‡å¤ä»£ç 

---

##### æ¨¡æ¿ A: å¤æ‚å¯¹è±¡å‚æ•°è§£æ

```python
import json
import logging
from typing import Optional, Union, Any

logger = logging.getLogger(__name__)


def parse_complex_param(
    param: Optional[Union[str, dict, list]],
    function_name: str,
    param_name: str = "complex_param"
) -> Optional[dict | list]:
    """è§£æå¤æ‚å‚æ•°,æ”¯æŒ JSON å­—ç¬¦ä¸²å’Œ dict/list å¯¹è±¡.

    Args:
        param: JSON å­—ç¬¦ä¸²æˆ– dict/list å¯¹è±¡
        function_name: è°ƒç”¨æ­¤å‡½æ•°çš„å‡½æ•°å(ç”¨äºæ—¥å¿—)
        param_name: å‚æ•°å(ç”¨äºæ—¥å¿—)

    Returns:
        è§£æåçš„ dict/list æˆ– None

    Raises:
        ValueError: JSON æ ¼å¼æ— æ•ˆ
    """
    if not param:
        return None

    # ğŸ” è°ƒè¯•æ—¥å¿—: è®°å½•æ¥æ”¶åˆ°çš„ç±»å‹
    logger.info(
        "ğŸ” [%s] %s type: %s, value: %s",
        function_name,
        param_name,
        type(param).__name__,
        str(param)[:200]  # é™åˆ¶é•¿åº¦
    )

    # âš¡ æ™ºèƒ½å¤„ç†: å¦‚æœæ˜¯ dict/list,ç›´æ¥ä½¿ç”¨
    if isinstance(param, (dict, list)):
        logger.warning(
            "âš ï¸ [%s] Received %s for %s instead of string! Auto-converting...",
            function_name,
            type(param).__name__,
            param_name
        )
        return param

    # âœ… æ ‡å‡†å¤„ç†: JSON å­—ç¬¦ä¸²è§£æ
    if isinstance(param, str):
        try:
            parsed = json.loads(param)
            logger.info("âœ… [%s] Successfully parsed %s", function_name, param_name)
            return parsed
        except json.JSONDecodeError as e:
            logger.error(
                "âŒ [%s] Invalid JSON format for %s: %s",
                function_name,
                param_name,
                str(e)
            )
            raise ValueError(f"Invalid JSON format for {param_name}: {e}")

    # å…¶ä»–ç±»å‹
    raise ValueError(
        f"{param_name} must be string, dict, or list, got {type(param).__name__}"
    )
```

**ä½¿ç”¨ç¤ºä¾‹**:
```python
async def my_tool(
    ctx: Context,
    filter_expression: Optional[Union[str, dict]] = None,
    tags: Optional[Union[str, List[dict]]] = None,
) -> dict[str, Any]:
    # è§£æå‚æ•°
    filter_dict = parse_complex_param(filter_expression, "my_tool", "filter_expression")
    tags_list = parse_complex_param(tags, "my_tool", "tags")

    # ä¸šåŠ¡é€»è¾‘
    if filter_dict:
        request_params["Filter"] = filter_dict
    if tags_list:
        request_params["Tags"] = tags_list
```

---

##### æ¨¡æ¿ B: åŸºç¡€ç±»å‹å‚æ•°è§£æ

```python
import logging
from typing import Optional, Union

logger = logging.getLogger(__name__)


def parse_int_param(
    param: Optional[Union[str, int]],
    function_name: str,
    param_name: str = "int_param",
    default: Optional[int] = None,
    min_value: Optional[int] = None,
    max_value: Optional[int] = None
) -> Optional[int]:
    """è§£ææ•´æ•°å‚æ•°,æ”¯æŒå­—ç¬¦ä¸²å’Œæ•´æ•°è¾“å…¥.

    Args:
        param: å­—ç¬¦ä¸²æˆ–æ•´æ•°
        function_name: è°ƒç”¨æ­¤å‡½æ•°çš„å‡½æ•°å(ç”¨äºæ—¥å¿—)
        param_name: å‚æ•°å(ç”¨äºæ—¥å¿—)
        default: é»˜è®¤å€¼(å½“ param ä¸º None æ—¶è¿”å›)
        min_value: æœ€å°å€¼(å¯é€‰)
        max_value: æœ€å¤§å€¼(å¯é€‰)

    Returns:
        è§£æåçš„æ•´æ•°æˆ– None

    Raises:
        ValueError: å‚æ•°æ ¼å¼æ— æ•ˆæˆ–è¶…å‡ºèŒƒå›´
    """
    if param is None:
        return default

    # ğŸ” è°ƒè¯•æ—¥å¿—: è®°å½•æ¥æ”¶åˆ°çš„ç±»å‹
    logger.info(
        "ğŸ” [%s] %s type: %s, value: %s",
        function_name,
        param_name,
        type(param).__name__,
        str(param)
    )

    # âš¡ æ™ºèƒ½å¤„ç†: å¦‚æœæ˜¯ int,ç›´æ¥ä½¿ç”¨
    if isinstance(param, int):
        result = param
    # âš ï¸ å¦‚æœæ˜¯å­—ç¬¦ä¸²,å°è¯•è½¬æ¢
    elif isinstance(param, str):
        logger.warning(
            "âš ï¸ [%s] Received string for %s instead of int! Auto-converting...",
            function_name,
            param_name
        )
        try:
            result = int(param)
        except ValueError as e:
            logger.error(
                "âŒ [%s] Invalid integer format for %s: %s",
                function_name,
                param_name,
                str(e)
            )
            raise ValueError(f"Invalid integer format for {param_name}: {e}")
    else:
        raise ValueError(
            f"{param_name} must be string or int, got {type(param).__name__}"
        )

    # èŒƒå›´éªŒè¯
    if min_value is not None and result < min_value:
        raise ValueError(f"{param_name} must be >= {min_value}, got {result}")
    if max_value is not None and result > max_value:
        raise ValueError(f"{param_name} must be <= {max_value}, got {result}")

    return result


def parse_float_param(
    param: Optional[Union[str, float, int]],
    function_name: str,
    param_name: str = "float_param",
    default: Optional[float] = None,
    min_value: Optional[float] = None,
    max_value: Optional[float] = None
) -> Optional[float]:
    """è§£ææµ®ç‚¹æ•°å‚æ•°,æ”¯æŒå­—ç¬¦ä¸²ã€æµ®ç‚¹æ•°å’Œæ•´æ•°è¾“å…¥.

    Args:
        param: å­—ç¬¦ä¸²ã€æµ®ç‚¹æ•°æˆ–æ•´æ•°
        function_name: è°ƒç”¨æ­¤å‡½æ•°çš„å‡½æ•°å(ç”¨äºæ—¥å¿—)
        param_name: å‚æ•°å(ç”¨äºæ—¥å¿—)
        default: é»˜è®¤å€¼(å½“ param ä¸º None æ—¶è¿”å›)
        min_value: æœ€å°å€¼(å¯é€‰)
        max_value: æœ€å¤§å€¼(å¯é€‰)

    Returns:
        è§£æåçš„æµ®ç‚¹æ•°æˆ– None

    Raises:
        ValueError: å‚æ•°æ ¼å¼æ— æ•ˆæˆ–è¶…å‡ºèŒƒå›´
    """
    if param is None:
        return default

    # ğŸ” è°ƒè¯•æ—¥å¿—
    logger.info(
        "ğŸ” [%s] %s type: %s, value: %s",
        function_name,
        param_name,
        type(param).__name__,
        str(param)
    )

    # âš¡ æ™ºèƒ½å¤„ç†
    if isinstance(param, (float, int)):
        result = float(param)
    elif isinstance(param, str):
        logger.warning(
            "âš ï¸ [%s] Received string for %s instead of float! Auto-converting...",
            function_name,
            param_name
        )
        try:
            result = float(param)
        except ValueError as e:
            logger.error(
                "âŒ [%s] Invalid float format for %s: %s",
                function_name,
                param_name,
                str(e)
            )
            raise ValueError(f"Invalid float format for {param_name}: {e}")
    else:
        raise ValueError(
            f"{param_name} must be string, float, or int, got {type(param).__name__}"
        )

    # èŒƒå›´éªŒè¯
    if min_value is not None and result < min_value:
        raise ValueError(f"{param_name} must be >= {min_value}, got {result}")
    if max_value is not None and result > max_value:
        raise ValueError(f"{param_name} must be <= {max_value}, got {result}")

    return result
```

**ä½¿ç”¨ç¤ºä¾‹**:
```python
async def compute_optimizer(
    ctx: Context,
    operation: str,
    max_results: Optional[Union[str, int]] = None,
    timeout: Optional[Union[str, float]] = None,
) -> dict[str, Any]:
    # è§£æå‚æ•°
    parsed_max_results = parse_int_param(
        max_results,
        "compute_optimizer",
        "max_results",
        min_value=1,
        max_value=100
    )
    parsed_timeout = parse_float_param(
        timeout,
        "compute_optimizer",
        "timeout",
        default=30.0,
        min_value=0.1
    )

    # ä¸šåŠ¡é€»è¾‘
    if parsed_max_results:
        request_params['maxResults'] = parsed_max_results
```

---

#### 3. **æ–‡ä»¶ç»„ç»‡ç»“æ„ - ç»Ÿä¸€æ¨¡å¼**

**è§„åˆ™**: æ‰€æœ‰ MCP Server ä½¿ç”¨ç›¸åŒçš„ç›®å½•ç»“æ„

```
src/<mcp-server-name>/
â”œâ”€â”€ awslabs/<package_name>/
â”‚   â”œâ”€â”€ server.py                    # FastMCP å…¥å£
â”‚   â”œâ”€â”€ tools/                       # Tool å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ *_tools.py
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ utilities/                   # âœ… é€šç”¨å·¥å…·æ¨¡å—
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ type_parsers.py          # âœ… ç±»å‹è§£æå‡½æ•°
â”‚       â”œâ”€â”€ aws_client.py            # AWS å®¢æˆ·ç«¯
â”‚       â”œâ”€â”€ formatters.py            # æ ¼å¼åŒ–å·¥å…·
â”‚       â””â”€â”€ logging_utils.py         # æ—¥å¿—å·¥å…·
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ utilities/                   # âœ… å·¥å…·å‡½æ•°æµ‹è¯•
â”‚   â”‚   â””â”€â”€ test_type_parsers.py
â”‚   â””â”€â”€ tools/
â”‚       â””â”€â”€ test_*_tools.py
â””â”€â”€ pyproject.toml
```

**å…³é”®æ–‡ä»¶**: `utilities/type_parsers.py`

```python
"""Type parsing utilities for handling parameter type conversions.

This module provides functions to parse parameters that may be passed
in different formats due to Gateway serialization behavior.

Supported conversions:
- Complex objects (dict, list): JSON string â†” native Python object
- Basic types (int, float): string â†” native Python type
"""

from .complex_param_parser import parse_complex_param
from .int_param_parser import parse_int_param
from .float_param_parser import parse_float_param

__all__ = [
    'parse_complex_param',
    'parse_int_param',
    'parse_float_param',
]
```

---

#### 4. **å‚æ•°æè¿°æ›´æ–° - æ–‡æ¡£è§„èŒƒ**

**è§„åˆ™**: å¿…é¡»åœ¨å‚æ•°æè¿°ä¸­è¯´æ˜æ”¯æŒå¤šç§ç±»å‹

```python
async def my_tool(
    ctx: Context,
    filter_expression: Annotated[
        Optional[Union[str, dict]],
        Field(
            description=(
                "Filter expression as a JSON string or dict object. "
                "Example: '{\"Dimensions\": {\"Key\": \"SERVICE\", \"Values\": [\"EC2\"]}}'"
            )
        )
    ] = None,
    max_results: Annotated[
        Optional[Union[str, int]],
        Field(
            description=(
                "Maximum number of results (1-100). Accepts string or integer."
            )
        )
    ] = None,
) -> dict[str, Any]:
    """Tool description...

    Args:
        ctx: The MCP context
        filter_expression: Filter expression as JSON string or dict object
        max_results: Maximum results (1-100), accepts string or integer

    Returns:
        Dict containing the response data
    """
```

---

#### 5. **é”™è¯¯å¤„ç† - ç»Ÿä¸€æ¨¡å¼**

**è§„åˆ™**: æ‰€æœ‰ tool å‡½æ•°å¿…é¡»åŒ…å«å®Œæ•´çš„å¼‚å¸¸å¤„ç†

```python
async def my_tool(
    ctx: Context,
    param1: str,
    filter_expression: Optional[Union[str, dict]] = None,
    max_results: Optional[Union[str, int]] = None,
    target_account_id: Optional[str] = None,
) -> dict[str, Any]:
    try:
        # ===== 1. è´¦å·ä¸Šä¸‹æ–‡åˆå§‹åŒ– =====
        if target_account_id:
            from entrypoint import _setup_account_context
            await _setup_account_context(target_account_id)

        # ===== 2. å‚æ•°è§£æ =====
        filter_dict = parse_complex_param(
            filter_expression,
            "my_tool",
            "filter_expression"
        )
        parsed_max_results = parse_int_param(
            max_results,
            "my_tool",
            "max_results",
            min_value=1,
            max_value=100
        )

        # ===== 3. ä¸šåŠ¡é€»è¾‘ =====
        client = create_aws_client("service", "region")
        response = client.some_api_call(
            Filter=filter_dict,
            MaxResults=parsed_max_results
        )
        return format_response("success", response)

    # ===== 4. å‚æ•°éªŒè¯é”™è¯¯ =====
    except ValueError as e:
        return format_response(
            'error',
            {'error_type': 'validation_error'},
            f'Invalid parameter: {str(e)}'
        )

    # ===== 5. è´¦å·ä¸Šä¸‹æ–‡é”™è¯¯ =====
    except AccountNotFoundError:
        return format_response(
            'error',
            {'error_type': 'account_not_found'},
            'Account not found. Please check the account ID.'
        )
    except CredentialDecryptionError:
        return format_response(
            'error',
            {'error_type': 'credential_error'},
            'Failed to decrypt credentials. Please contact administrator.'
        )
    except AssumeRoleError:
        return format_response(
            'error',
            {'error_type': 'assume_role_error'},
            'Failed to assume role. Please check IAM role configuration.'
        )
    except DatabaseConnectionError:
        return format_response(
            'error',
            {'error_type': 'database_error'},
            'Database connection failed. Please try again later.'
        )

    # ===== 6. AWS API é”™è¯¯ =====
    except Exception as e:
        return await handle_aws_error(ctx, e, "operation", "Service")
```

---

## ğŸ“Š ä¸‰ä¸ªé¡¹ç›®çš„å¯¹æ¯”åˆ†æ

### RISP MCP (å·²ä¿®å¤)

| ç»´åº¦ | ä¿®å¤å‰ | ä¿®å¤å | è¯„åˆ† |
|------|--------|--------|------|
| **å‚æ•°ç±»å‹** | `filter_expression: Optional[str]` | `filter_expression: Optional[Union[str, dict]]` | â­â­â­â­â­ |
| **è§£æå‡½æ•°** | ç®€å•çš„ `json.loads()` | `parse_filter_expression()` (æ™ºèƒ½æ£€æµ‹) | â­â­â­â­â­ |
| **æ—¥å¿—è®°å½•** | âŒ æ—  | âœ… è¯¦ç»†çš„ç±»å‹æ—¥å¿— (ğŸ”âš ï¸âœ…âŒ) | â­â­â­â­â­ |
| **é”™è¯¯å¤„ç†** | âœ… å®Œæ•´ | âœ… å®Œæ•´ + ValueError | â­â­â­â­â­ |
| **ä»£ç å¤ç”¨** | âŒ æ¯ä¸ªå‡½æ•°é‡å¤ | âœ… æå–å…¬å…±å‡½æ•° | â­â­â­â­â­ |

**ä¿®å¤æ–‡ä»¶**:
- `handlers/sp_handler.py` (4 ä¸ªå‡½æ•°)
- `handlers/ri_handler.py` (2 ä¸ªå‡½æ•°)

**å…³é”®ä»£ç **:
```python
def parse_filter_expression(
    filter_expression: Optional[Union[str, dict]],
    function_name: str
) -> Optional[dict]:
    """å®Œç¾å®ç° Union ç±»å‹ + æ™ºèƒ½è½¬æ¢ + è¯¦ç»†æ—¥å¿—"""
    if not filter_expression:
        return None

    # ğŸ” è°ƒè¯•æ—¥å¿—
    logger.info("ğŸ” [%s] filter_expression type: %s", function_name, type(filter_expression).__name__)

    # âš¡ dict â†’ ç›´æ¥ä½¿ç”¨
    if isinstance(filter_expression, dict):
        logger.warning("âš ï¸ [%s] Received dict instead of string!", function_name)
        return filter_expression

    # âœ… str â†’ JSON è§£æ
    try:
        return json.loads(filter_expression)
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON format: {e}")
```

---

### CloudTrail MCP (æœªå‘ç°é—®é¢˜)

| ç»´åº¦ | å½“å‰çŠ¶æ€ | åŸå› åˆ†æ | è¯„åˆ† |
|------|---------|---------|------|
| **å‚æ•°ç±»å‹** | æ—  `Optional[int]` å‚æ•° | âœ… ä¸æ¶‰åŠé—®é¢˜å‚æ•°ç±»å‹ | â­â­â­â­â­ |
| **å¤æ‚å‚æ•°** | æ—  `Optional[dict]` å‚æ•° | âœ… ä¸æ¶‰åŠé—®é¢˜å‚æ•°ç±»å‹ | â­â­â­â­â­ |
| **æ¶æ„è®¾è®¡** | ä½¿ç”¨ `target_account_id` å¤šè´¦å·æ¨¡å¼ | âœ… å·²å®Œæˆå¤šè´¦å·æ”¹é€  | â­â­â­â­â­ |
| **ä»£ç è´¨é‡** | æ¸…æ™°çš„æ¨¡å—åŒ–è®¾è®¡ | âœ… å‚è€ƒæ ‡å‡† | â­â­â­â­â­ |

**ç»“è®º**: CloudTrail MCP æš‚æœªé‡åˆ°å‚æ•°ç±»å‹é—®é¢˜ï¼Œä½†å»ºè®®**é¢„é˜²æ€§**æ·»åŠ ç±»å‹è§£æå·¥å…·ã€‚

---

### Billing MCP (å¾…ä¿®å¤)

| ç»´åº¦ | å½“å‰çŠ¶æ€ | é—®é¢˜ä¸¥é‡åº¦ | ä¼˜å…ˆçº§ |
|------|---------|-----------|-------|
| **max_results å‚æ•°** | âŒ `Optional[int]` | ğŸ”´ é«˜ | P0 |
| **å—å½±å“å‡½æ•°æ•°é‡** | ~25 ä¸ª | ğŸ”´ é«˜ | P0 |
| **å—å½±å“æ–‡ä»¶æ•°é‡** | 14 ä¸ªä¸»æ–‡ä»¶ + 3 ä¸ªè¾…åŠ©æ–‡ä»¶ | ğŸ”´ é«˜ | P0 |
| **å·²æœ‰è§£æå‡½æ•°** | âœ… `parse_json()` (ä»…æ”¯æŒ str) | ğŸŸ¡ ä¸­ | P1 |
| **æ—¥å¿—è®°å½•** | âš ï¸ åŸºç¡€ | ğŸŸ¡ ä¸­ | P1 |

**å¾…ä¿®å¤æ¸…å•**:

**P0 ä¼˜å…ˆçº§** (ç«‹å³ä¿®å¤):
1. `compute_optimizer_tools.py` - `compute_optimizer()`
2. `cost_optimization_hub_tools.py` - `list_recommendations()`
3. `cost_anomaly_tools.py` - `get_anomalies()`, `get_anomaly_subscriptions()`
4. `cost_explorer_tools.py` - `get_cost_forecast()`

**P1 ä¼˜å…ˆçº§** (æœ¬å‘¨ä¿®å¤):
5. `cost_comparison_tools.py` - 3 ä¸ªå‡½æ•°
6. `free_tier_usage_tools.py` - 1 ä¸ªå‡½æ•°
7. `bcm_pricing_calculator_tools.py` - 4 ä¸ªå‡½æ•°
8. `aws_pricing_tools.py` - 1 ä¸ªå‡½æ•°

**ä¿®å¤æ–¹æ¡ˆ**:
```python
# 1. åˆ›å»º utilities/type_parsers.py
from .complex_param_parser import parse_complex_param
from .int_param_parser import parse_int_param

# 2. ä¿®æ”¹å‚æ•°ç±»å‹
max_results: Optional[Union[str, int]] = None

# 3. ä½¿ç”¨è§£æå‡½æ•°
parsed_max_results = parse_int_param(
    max_results,
    "compute_optimizer",
    "max_results",
    min_value=1,
    max_value=100
)
```

---

## âœ… æ ‡å‡†åŒ–å®æ–½æ¸…å•

### Phase 1: é¡¹ç›®ç»“æ„å‡†å¤‡

- [ ] åˆ›å»º `utilities/` ç›®å½• (å¦‚æœä¸å­˜åœ¨)
- [ ] åˆ›å»º `utilities/type_parsers.py`
- [ ] åˆ›å»º `tests/utilities/test_type_parsers.py`
- [ ] æ·»åŠ  `__init__.py` å¯¼å‡º

### Phase 2: å·¥å…·å‡½æ•°å®ç°

- [ ] å®ç° `parse_complex_param()` (æ”¯æŒ dict/list)
- [ ] å®ç° `parse_int_param()` (æ”¯æŒ int)
- [ ] å®ç° `parse_float_param()` (æ”¯æŒ float)
- [ ] ç¼–å†™å•å…ƒæµ‹è¯• (æ¯ä¸ªå‡½æ•° 5+ æµ‹è¯•ç”¨ä¾‹)

### Phase 3: Tool å‡½æ•°ä¿®æ”¹

- [ ] è¯†åˆ«æ‰€æœ‰å—å½±å“çš„å‚æ•°
- [ ] ä¿®æ”¹å‚æ•°ç±»å‹ä¸º `Union[str, target_type]`
- [ ] æ·»åŠ è§£æå‡½æ•°è°ƒç”¨
- [ ] æ›´æ–°å‚æ•°æè¿°
- [ ] æ·»åŠ  ValueError å¼‚å¸¸å¤„ç†

### Phase 4: æµ‹è¯•éªŒè¯

- [ ] å•å…ƒæµ‹è¯• - å­—ç¬¦ä¸²è¾“å…¥
- [ ] å•å…ƒæµ‹è¯• - åŸç”Ÿç±»å‹è¾“å…¥
- [ ] å•å…ƒæµ‹è¯• - æ— æ•ˆè¾“å…¥
- [ ] é›†æˆæµ‹è¯• - Gateway è°ƒç”¨
- [ ] å›å½’æµ‹è¯• - åŸæœ‰åŠŸèƒ½

### Phase 5: æ–‡æ¡£æ›´æ–°

- [ ] æ›´æ–° README.md
- [ ] æ›´æ–° API æ–‡æ¡£
- [ ] æ›´æ–° CHANGELOG.md
- [ ] åˆ›å»ºè¿ç§»æŒ‡å—

---

## ğŸ“ ä»£ç æ¨¡æ¿

### å®Œæ•´çš„ utilities/type_parsers.py

```python
"""Type parsing utilities for handling parameter type conversions.

This module provides standardized functions to parse parameters that may
be passed in different formats due to Gateway serialization behavior.

Key Features:
- Support for complex objects (dict, list)
- Support for basic types (int, float)
- Detailed logging with emoji markers (ğŸ”âš ï¸âœ…âŒ)
- Comprehensive error handling
- Range validation for numeric types

Usage:
    from utilities.type_parsers import (
        parse_complex_param,
        parse_int_param,
        parse_float_param
    )

    # Complex object
    filter_dict = parse_complex_param(
        filter_expression,
        "my_function",
        "filter_expression"
    )

    # Integer
    max_results = parse_int_param(
        max_results,
        "my_function",
        "max_results",
        min_value=1,
        max_value=100
    )
"""

import json
import logging
from typing import Any, List, Optional, Union

logger = logging.getLogger(__name__)


def parse_complex_param(
    param: Optional[Union[str, dict, list]],
    function_name: str,
    param_name: str = "complex_param"
) -> Optional[Union[dict, List]]:
    """è§£æå¤æ‚å‚æ•° (å®Œæ•´å®ç°è§ä¸Šæ–¹æ¨¡æ¿ A)"""
    # ... (è§ä¸Šæ–¹å®Œæ•´ä»£ç )


def parse_int_param(
    param: Optional[Union[str, int]],
    function_name: str,
    param_name: str = "int_param",
    default: Optional[int] = None,
    min_value: Optional[int] = None,
    max_value: Optional[int] = None
) -> Optional[int]:
    """è§£ææ•´æ•°å‚æ•° (å®Œæ•´å®ç°è§ä¸Šæ–¹æ¨¡æ¿ B)"""
    # ... (è§ä¸Šæ–¹å®Œæ•´ä»£ç )


def parse_float_param(
    param: Optional[Union[str, float, int]],
    function_name: str,
    param_name: str = "float_param",
    default: Optional[float] = None,
    min_value: Optional[float] = None,
    max_value: Optional[float] = None
) -> Optional[float]:
    """è§£ææµ®ç‚¹æ•°å‚æ•° (å®Œæ•´å®ç°è§ä¸Šæ–¹æ¨¡æ¿ B)"""
    # ... (è§ä¸Šæ–¹å®Œæ•´ä»£ç )


__all__ = [
    'parse_complex_param',
    'parse_int_param',
    'parse_float_param',
]
```

### å•å…ƒæµ‹è¯•æ¨¡æ¿

```python
"""Tests for type parsing utilities."""

import pytest
from utilities.type_parsers import (
    parse_complex_param,
    parse_int_param,
    parse_float_param
)


class TestParseComplexParam:
    """Tests for parse_complex_param()"""

    def test_dict_input(self):
        """Should return dict as-is"""
        result = parse_complex_param(
            {"key": "value"},
            "test_func",
            "param"
        )
        assert result == {"key": "value"}

    def test_json_string_input(self):
        """Should parse JSON string"""
        result = parse_complex_param(
            '{"key": "value"}',
            "test_func",
            "param"
        )
        assert result == {"key": "value"}

    def test_none_input(self):
        """Should return None"""
        result = parse_complex_param(None, "test_func", "param")
        assert result is None

    def test_invalid_json(self):
        """Should raise ValueError"""
        with pytest.raises(ValueError, match="Invalid JSON format"):
            parse_complex_param("invalid json", "test_func", "param")

    def test_list_input(self):
        """Should return list as-is"""
        result = parse_complex_param(
            [{"key": "value"}],
            "test_func",
            "param"
        )
        assert result == [{"key": "value"}]


class TestParseIntParam:
    """Tests for parse_int_param()"""

    def test_int_input(self):
        """Should return int as-is"""
        result = parse_int_param(50, "test_func", "param")
        assert result == 50

    def test_string_input(self):
        """Should parse string to int"""
        result = parse_int_param("50", "test_func", "param")
        assert result == 50

    def test_none_input(self):
        """Should return None"""
        result = parse_int_param(None, "test_func", "param")
        assert result is None

    def test_none_with_default(self):
        """Should return default value"""
        result = parse_int_param(None, "test_func", "param", default=100)
        assert result == 100

    def test_invalid_string(self):
        """Should raise ValueError"""
        with pytest.raises(ValueError, match="Invalid integer format"):
            parse_int_param("invalid", "test_func", "param")

    def test_min_value_validation(self):
        """Should enforce minimum value"""
        with pytest.raises(ValueError, match="must be >= 1"):
            parse_int_param(0, "test_func", "param", min_value=1)

    def test_max_value_validation(self):
        """Should enforce maximum value"""
        with pytest.raises(ValueError, match="must be <= 100"):
            parse_int_param(101, "test_func", "param", max_value=100)


class TestParseFloatParam:
    """Tests for parse_float_param()"""

    def test_float_input(self):
        """Should return float as-is"""
        result = parse_float_param(3.14, "test_func", "param")
        assert result == 3.14

    def test_int_input(self):
        """Should convert int to float"""
        result = parse_float_param(50, "test_func", "param")
        assert result == 50.0

    def test_string_input(self):
        """Should parse string to float"""
        result = parse_float_param("3.14", "test_func", "param")
        assert result == 3.14

    def test_invalid_string(self):
        """Should raise ValueError"""
        with pytest.raises(ValueError, match="Invalid float format"):
            parse_float_param("invalid", "test_func", "param")
```

---

## ğŸš€ å¿«é€Ÿå®æ–½æŒ‡å—

### æ–°é¡¹ç›® (ä»é›¶å¼€å§‹)

1. **å¤åˆ¶æ¨¡æ¿æ–‡ä»¶**:
   ```bash
   cp costq/docs/20260122_å‚æ•°ç±»å‹é—®é¢˜æ ‡å‡†åŒ–ä¿®å¤æ–¹æ¡ˆ/templates/type_parsers.py \
      src/<your-mcp>/utilities/

   cp costq/docs/20260122_å‚æ•°ç±»å‹é—®é¢˜æ ‡å‡†åŒ–ä¿®å¤æ–¹æ¡ˆ/templates/test_type_parsers.py \
      src/<your-mcp>/tests/utilities/
   ```

2. **Tool å‡½æ•°è®¾è®¡è§„èŒƒ**:
   - æ‰€æœ‰ `dict/list` å‚æ•°ä½¿ç”¨ `Optional[Union[str, dict/list]]`
   - æ‰€æœ‰ `int/float` å‚æ•°ä½¿ç”¨ `Optional[Union[str, int/float]]`
   - è°ƒç”¨ç›¸åº”çš„ `parse_*_param()` å‡½æ•°

3. **æµ‹è¯•éªŒè¯**:
   ```bash
   pytest tests/utilities/test_type_parsers.py -v
   ```

### ç°æœ‰é¡¹ç›® (ä¿®å¤)

æŒ‰ç…§æœ¬æ–‡æ¡£ä¸­çš„ **Billing MCP ä¿®å¤è®¡åˆ’** æ‰§è¡Œ:
1. åˆ›å»º `utilities/type_parsers.py`
2. ä¿®æ”¹æ‰€æœ‰å—å½±å“çš„ tool å‡½æ•°
3. è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶
4. éƒ¨ç½²éªŒè¯

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [RISP MCP filter_expression ä¿®å¤æ–¹æ¡ˆ](../20260120_filter_expressionåˆ†æ/é—®é¢˜æ€»ç»“ä¸ä¿®å¤æ–¹æ¡ˆ.md)
- [RISP MCP å‚æ•°ç±»å‹é—®é¢˜åˆ†æ](../20260120_RISP_MCPå‚æ•°ç±»å‹é—®é¢˜æœ€ç»ˆåˆ†æ.md)
- [Billing MCP ä¿®å¤è®¡åˆ’](../20260122_billing_mcp_å‚æ•°ç±»å‹ä¿®å¤/ä¿®å¤è®¡åˆ’.md)
- [MCP Gateway é€‚é…æ”¹é€ æŒ‡å—](../20260117_MCP-Gateway-é€‚é…æ”¹é€ åˆ†æ/02_æ”¹é€ æ­¥éª¤æŒ‡å—.md)

---

## ğŸ“ æ€»ç»“

### å…³é”®è¦ç‚¹

1. **é—®é¢˜æ ¹æº**: FastMCP Schema ç”Ÿæˆ + Gateway åºåˆ—åŒ–ä¸ç¡®å®š + Pydantic éªŒè¯æ‹¦æˆª
2. **è§£å†³æ–¹æ¡ˆ**: Union ç±»å‹ + æ™ºèƒ½è½¬æ¢ + è¯¦ç»†æ—¥å¿—
3. **æ ‡å‡†åŒ–**: ç»Ÿä¸€çš„å·¥å…·å‡½æ•° + ç»Ÿä¸€çš„ç›®å½•ç»“æ„ + ç»Ÿä¸€çš„é”™è¯¯å¤„ç†
4. **å¯å¤ç”¨**: æ¨¡æ¿ä»£ç å¯ä»¥ç›´æ¥å¤åˆ¶åˆ°ä»»ä½• MCP Server é¡¹ç›®

### æœ€ä½³å®è·µ

- âœ… ä½¿ç”¨ Union ç±»å‹æ”¾å®½éªŒè¯
- âœ… è¿è¡Œæ—¶ç±»å‹æ£€æµ‹å’Œæ™ºèƒ½è½¬æ¢
- âœ… è¯¦ç»†çš„æ—¥å¿—è®°å½• (ğŸ”âš ï¸âœ…âŒ)
- âœ… å®Œæ•´çš„å•å…ƒæµ‹è¯•è¦†ç›–
- âœ… ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æ¨¡å¼
- âœ… æ¸…æ™°çš„å‚æ•°æè¿°æ–‡æ¡£

### æœªæ¥æ”¹è¿›

1. å‘ FastMCP å›¢é˜Ÿæäº¤ Issue (Schema ç”Ÿæˆé—®é¢˜)
2. è€ƒè™‘åˆ›å»º MCP Server è„šæ‰‹æ¶å·¥å…·
3. å»ºç«‹è·¨é¡¹ç›®çš„å…¬å…±åº“ (`costq-mcp-commons`)

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2026-01-22
**ä½œè€…**: DeepV Code AI Assistant
**çŠ¶æ€**: âœ… æ ‡å‡†åŒ–æ–¹æ¡ˆå·²å®Œæˆ
