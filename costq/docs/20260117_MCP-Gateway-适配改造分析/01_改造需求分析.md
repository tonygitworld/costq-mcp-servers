# MCP Server 多账号权限传递改造需求分析

> 本文档基于 **cloudtrail-mcp-server** 的实际改造方案编写

## 1. 背景说明

### 1.1 架构概述
```
┌─────────────────┐
│ Strands Agent   │  (AgentCore Runtime)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ AgentCore       │  (权限网关)
│ Gateway         │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ MCP Servers     │  (AgentCore Runtime)
│ (多个后端服务)   │
└─────────────────┘
```

### 1.2 核心问题
**问题**：Strands Agent 需要访问**目标账号**的 AWS 资源，但 MCP Server 默认使用**运行时账号**的凭证。

**场景示例**：
- Agent 运行在 Account A (运行时账号)
- 用户想查询 Account B (目标账号) 的 CloudTrail 事件
- MCP Server 需要获取 Account B 的临时凭证

### 1.3 解决方案
通过 **账号上下文传递机制** 实现：
1. Agent 通过 Gateway 传递 `target_account_id` 参数
2. MCP Server 从数据库查询账号凭证信息
3. 根据账号类型（AKSK/IAM Role）获取临时凭证
4. 设置环境变量，boto3 自动使用目标账号凭证

---

## 2. 改造范围

### 2.1 改造的 MCP Server
已改造完成：
- ✅ `cloudtrail-mcp-server` (参考实现)

待改造：
- 其他需要多账号访问能力的 MCP Servers（如 CloudWatch、Cost Explorer、S3 等）

### 2.2 改造层级
```
src/cloudtrail-mcp-server/
├── Dockerfile-AgentCore-Runtime       # ✅ 新增：Runtime 部署专用 Dockerfile
├── cred_extract_services/             # ✅ 新增：凭证提取服务
│   ├── __init__.py
│   ├── aws_client.py                  # STS AssumeRole
│   ├── context_manager.py             # 环境变量管理
│   ├── credential_extractor.py        # 凭证提取核心
│   ├── crypto.py                      # AKSK 解密
│   ├── database.py                    # 数据库查询
│   └── exceptions.py                  # 自定义异常
├── awslabs/.../server.py              # ✅ 修改：FastMCP 初始化 + _setup_account_context 函数
│   ├── FastMCP 初始化配置            # 添加 host="0.0.0.0" 和 stateless_http=True
│   └── _setup_account_context()      # 统一账号上下文设置函数
├── awslabs/.../tools/                 # ✅ 修改：所有 tool 函数
│   └── cloudtrail_tools.py           # 添加 target_account_id 参数
└── awslabs/.../utilities/             # ⚠️ 可能需要修改（日志库统一）
```

### 2.3 文件可复用性总结

| 文件/目录 | 可复用性 | 需要修改 | 说明 |
|-----------|---------|---------|------|
| `cred_extract_services/` | ✅ **100% 可复用** | ❌ 无需修改 | 完全自包含，不依赖项目代码 |
| `Dockerfile-AgentCore-Runtime` | ✅ **95% 可复用** | ⚠️ 修改 CMD | 仅需修改启动命令中的包名 |
| `server.py` 中的 `_setup_account_context()` | ✅ **100% 可复用** | ❌ 无需修改 | 统一账号上下文设置函数 |
| `server.py` 中的 FastMCP 配置 | ⚠️ **需要添加** | ✅ 添加参数 | 添加 `host` 和 `stateless_http` |
| `awslabs/.../tools/*.py` | ❌ **需要修改** | ✅ 批量修改 | 所有 tool 函数添加 `target_account_id` 参数 |

**核心优势**：
- ✅ **90% 的基础设施代码可直接复制**
- ✅ **改造时间从 2-3 小时缩短到 15-20 分钟**
- ✅ **降低出错风险**（使用经过验证的代码）

---

### 2.4 ⚠️ 重要：日志库统一检查

**在改造过程中，必须检查并统一日志库**

#### 2.4.1 为什么重要？

**问题**：混用 `loguru` 和 `logging` 会导致：
- ❌ OpenTelemetry 无法捕获 `loguru` 日志
- ❌ 缺少 trace ID 和 span ID（无法追踪请求链路）
- ❌ CloudWatch 日志不完整
- ❌ 日志格式不一致

**影响**：
- 🔍 **调试困难**：无法通过 trace_id 追踪完整的请求链路
- 📊 **监控不完整**：部分日志缺失导致无法全面分析
- 🚨 **告警不准确**：基于日志的告警可能失效

#### 2.4.2 检查方法

```bash
# 在项目根目录执行
cd src/<mcp-server-name>/
grep -r "from loguru" awslabs/ --include="*.py"

# 如果有输出，需要迁移到 logging
```

**常见情况**：
| 文件 | 使用日志库 | 是否需要迁移 |
|------|-----------|-------------|
| `server.py` | `logging` ✅ | 无需修改 |
| `tools/*.py` | `loguru` ❌ | **需要迁移** |
| `utilities/*.py` | `logging` ✅ | 无需修改 |

#### 2.4.3 快速迁移步骤

**Step 1: 替换导入**
```python
# 修改前
from loguru import logger

# 修改后
import logging
logger = logging.getLogger(__name__)
```

**Step 2: 移除依赖**
```toml
# pyproject.toml
dependencies = [
    "boto3>=1.38.22",
    # "loguru>=0.7.0",  # ❌ 删除
    "mcp[cli]>=1.23.0",
    "pydantic>=2.10.6",
]
```

**Step 3: 验证**
```bash
# 确认没有 loguru 引用
grep -r "loguru" . --include="*.py" --include="*.toml"
```

---

## 3. 核心改造点

### 3.1 新增凭证提取服务层 (cred_extract_services/)
**目的**：自包含的凭证管理模块，不依赖项目代码

#### 3.1.1 模块职责
| 模块 | 职责 | 依赖 |
|------|------|------|
| `database.py` | 查询 `aws_accounts` 表和 `organizations` 表 | SQLAlchemy, boto3 (Secrets Manager) |
| `crypto.py` | 解密 AKSK 凭证 (Fernet) | cryptography |
| `aws_client.py` | STS AssumeRole 获取临时凭证 | boto3 |
| `credential_extractor.py` | 凭证提取核心逻辑 | 上述模块 |
| `context_manager.py` | 设置环境变量 (boto3 标准变量) | 无 |
| `exceptions.py` | 自定义异常类 | 无 |

#### 3.1.2 数据库查询逻辑
```sql
SELECT
    a.id, a.account_id, a.alias, a.auth_type,
    a.access_key_id, a.secret_access_key_encrypted,
    a.role_arn, a.region, a.org_id,
    o.external_id  -- 从 organizations 表获取
FROM aws_accounts a
LEFT JOIN organizations o ON a.org_id = o.id
WHERE a.account_id = :account_id
```

**关键字段说明**：
- `auth_type`: "aksk" 或 "iam_role"
- `access_key_id`: AKSK 类型，明文存储
- `secret_access_key_encrypted`: AKSK 类型，Fernet 加密
- `role_arn`: IAM Role 类型
- `external_id`: IAM Role 类型，从 organizations 表获取

#### 3.1.3 凭证提取流程
```python
async def extract_aws_credentials(account_id: str) -> dict:
    # 1. 查询数据库
    account = await query_account(account_id)

    # 2. 根据 auth_type 选择分支
    if account["auth_type"] == "aksk":
        # 解密 Secret Access Key
        secret_key = decrypt_aksk(account["encrypted_secret_key"])
        return {
            "access_key_id": account["access_key_id"],  # 明文
            "secret_access_key": secret_key,
            "session_token": None,
            "region": account["region"],
            "account_id": account["account_id"]
        }

    elif account["auth_type"] == "iam_role":
        # AssumeRole 获取临时凭证
        credentials = await assume_role(
            role_arn=account["role_arn"],
            session_name=f"costq-{uuid.uuid4()}",
            external_id=account["external_id"],  # 必须！
            region=account["region"]
        )
        return {
            "access_key_id": credentials["AccessKeyId"],
            "secret_access_key": credentials["SecretAccessKey"],
            "session_token": credentials["SessionToken"],
            "region": account["region"],
            "account_id": account["account_id"]
        }
```

#### 3.1.4 环境变量设置
```python
def set_aws_credentials(
    access_key_id: str,
    secret_access_key: str,
    session_token: Optional[str] = None,
    region: str = "us-east-1",
) -> None:
    os.environ["AWS_ACCESS_KEY_ID"] = access_key_id
    os.environ["AWS_SECRET_ACCESS_KEY"] = secret_access_key

    # Session Token 处理：有值则设置，无值则删除
    if session_token:
        os.environ["AWS_SESSION_TOKEN"] = session_token
    elif "AWS_SESSION_TOKEN" in os.environ:
        del os.environ["AWS_SESSION_TOKEN"]

    os.environ["AWS_DEFAULT_REGION"] = region
```

**关键点**：
- boto3 自动识别标准环境变量（AWS_ACCESS_KEY_ID、AWS_SECRET_ACCESS_KEY、AWS_SESSION_TOKEN、AWS_DEFAULT_REGION），无需额外配置
- Session Token 的删除逻辑避免残留（AKSK 模式没有 session token）
- 不设置 AWS_ACCOUNT_ID，业务代码通过 STS GetCallerIdentity API 动态获取

---

### 3.2 修改 server.py

#### 3.2.1 添加 FastMCP 配置参数

```python
from mcp.server.fastmcp import FastMCP

# Create FastMCP server for AgentCore Runtime
# AgentCore requires stateless HTTP servers on 0.0.0.0:8000/mcp
mcp = FastMCP(
    name='awslabs.cloudtrail-mcp-server',
    instructions='...',
    dependencies=[
        'boto3',
        'botocore',
        'pydantic',
    ],
    host="0.0.0.0",           # ✅ 新增：监听地址
    stateless_http=True       # ✅ 新增：无状态 HTTP 模式
)
```

#### 3.2.2 添加 _setup_account_context 函数

**在 server.py 中添加统一的账号上下文设置函数**：

```python
from cred_extract_services.context_manager import set_aws_credentials
from cred_extract_services.credential_extractor import extract_aws_credentials
from cred_extract_services.exceptions import (
    AccountNotFoundError,
    AssumeRoleError,
    CredentialDecryptionError,
    CredentialExtractionError,
    DatabaseConnectionError,
)

# 导出异常类和函数
__all__ = [
    "_setup_account_context",
    "mcp",
    "main",
    "CredentialExtractionError",
    "AccountNotFoundError",
    "CredentialDecryptionError",
    "AssumeRoleError",
    "DatabaseConnectionError",
]


async def _setup_account_context(
    target_account_id: str,
) -> dict[str, str]:
    """设置 AWS 凭证上下文

    统一入口函数，完成以下操作：
    1. 查询账号信息（自包含数据库查询）
    2. 提取凭证（AKSK 解密 / IAM Role AssumeRole）
    3. 设置环境变量

    Args:
        target_account_id: AWS 账号 ID

    Returns:
        凭证信息字典（已脱敏）

    Raises:
        AccountNotFoundError: 账号不存在
        CredentialDecryptionError: AKSK 解密失败
        AssumeRoleError: IAM Role AssumeRole 失败
        DatabaseConnectionError: 数据库连接失败
    """
    logger.info("开始设置 AWS 凭证上下文")

    # 1. 提取凭证
    credentials = await extract_aws_credentials(target_account_id)

    # 2. 设置环境变量
    set_aws_credentials(
        access_key_id=credentials["access_key_id"],
        secret_access_key=credentials["secret_access_key"],
        session_token=credentials.get("session_token"),
        region=credentials["region"],
    )

    # 3. 返回脱敏信息
    cred_info = {
        "account_id": credentials["account_id"],
        "account_alias": credentials.get("alias", "Unknown"),
        "auth_type": credentials["auth_type"],
        "region": credentials["region"],
    }

    logger.info(f"✅ AWS 凭证上下文设置完成: {cred_info}")
    return cred_info
```

#### 3.2.3 修改 main() 函数

```python
def main():
    """Run the MCP server with streamable HTTP transport for AgentCore."""
    # AgentCore Runtime expects servers to run with streamable-http transport
    mcp.run(transport="streamable-http")

if __name__ == '__main__':
    main()
```

---

### 3.3 修改所有 Tool 函数

#### 3.3.1 参数修改模式
**所有 tool 函数都新增参数**：
```python
@server.tool(name="tool-name", description="...")
async def tool_function(
    ctx: Context,
    target_account_id: Optional[str] = None,  # ✅ 新增参数
    # ... 其他业务参数
) -> Dict[str, Any]:
```

#### 3.3.2 标准改造模板

```python
# 1. 导入异常类（文件顶部）
from awslabs.cloudtrail_mcp_server.server import (
    _setup_account_context,
    AccountNotFoundError,
    CredentialDecryptionError,
    AssumeRoleError,
    DatabaseConnectionError,
)

@server.tool(name="tool-name", description="...")
async def tool_function(
    ctx: Context,
    param1: str,                              # 必需参数（保持原位置）
    target_account_id: Optional[str] = None,  # ✅ 新增：第一个可选参数
    param2: Optional[int] = None,             # 可选参数（保持原位置）
) -> Dict[str, Any]:
    try:
        # ===== 账号上下文初始化 =====
        if target_account_id:
            await _setup_account_context(target_account_id)

        # ===== 原有逻辑（完全不变）=====
        client = create_aws_client("service", "region")
        response = client.some_api_call(param1=param1)
        return format_response("success", response)

    # ===== 异常处理 =====
    except AccountNotFoundError:
        return format_response('error', {'error_type': 'account_not_found'},
                               'Account not found. Please check the account ID.')
    except CredentialDecryptionError:
        return format_response('error', {'error_type': 'credential_error'},
                               'Failed to decrypt credentials. Please contact administrator.')
    except AssumeRoleError:
        return format_response('error', {'error_type': 'assume_role_error'},
                               'Failed to assume role. Please check IAM role configuration.')
    except DatabaseConnectionError:
        return format_response('error', {'error_type': 'database_error'},
                               'Database connection failed. Please try again later.')
    except Exception as e:
        return await handle_aws_error(ctx, e, "operation", "Service")
```

#### 3.3.3 异常处理

**导入自定义异常**：
```python
from awslabs.cloudtrail_mcp_server.server import (
    AccountNotFoundError,
    CredentialDecryptionError,
    AssumeRoleError,
    DatabaseConnectionError,
)
```

**统一错误返回格式**：
```python
{
    "status": "error",
    "data": {
        "error_type": "account_not_found" | "credential_error" | "assume_role_error" | "database_error"
    },
    "message": "User-friendly error message"
}
```

---

### 3.4 工具函数保持不变

#### 3.4.1 aws_service_base.py
```python
def create_aws_client(service_name: str, region_name: Optional[str] = None) -> Any:
    """创建 AWS 客户端（逻辑完全不变）

    boto3 会自动从环境变量读取凭证：
    - AWS_ACCESS_KEY_ID
    - AWS_SECRET_ACCESS_KEY
    - AWS_SESSION_TOKEN (可选)
    - AWS_DEFAULT_REGION
    """
    # ... 原有逻辑不变
    session = boto3.Session(region_name=region)
    return session.client(service_name, config=config)
```

**关键点**：
- 不需要修改任何 `create_aws_client` 调用
- boto3 自动从环境变量读取凭证
- **零侵入性原则**：业务代码无感知

---

## 4. 改造原则总结

### 4.1 零侵入性原则
✅ **仅修改目标代码，不改变业务逻辑和函数签名**

- Tool 函数新增可选参数 `target_account_id`
  - **参数位置规则**：必须放在所有必需参数之后、其他可选参数之前
  - **示例**：`async def tool(ctx, required_param, target_account_id=None, optional_param=None)`
- 业务逻辑完全不变
- 工具函数（`create_aws_client`）不变

### 4.2 自包含原则
✅ **凭证提取服务完全独立**

- `cred_extract_services/` 不依赖项目代码
- 可以单独测试、复用

### 4.3 安全原则
✅ **日志安全**

- 不记录任何敏感信息（密码、密钥、凭证、连接串）
- 仅记录操作结果和元数据

✅ **异常安全**

- 统一的自定义异常类型
- 清晰的错误提示

### 4.4 环境变量原则
✅ **标准化**

- 使用 boto3 标准环境变量
- 不自定义 boto3 配置

✅ **生命周期管理**

- Session Token 有值则设置，无值则删除
- 避免环境变量残留

---

## 5. Dockerfile 改造详解

### 5.1 Dockerfile-AgentCore-Runtime

**目的**：构建专门用于 AgentCore Runtime 部署的 ARM64 镜像

**关键改造点**：

#### 5.1.1 文件复制（必需）
```dockerfile
# 复制凭证提取服务（改造核心）
COPY --chown=app:app ./cred_extract_services /app/cred_extract_services
```

**说明**：
- `cred_extract_services/`：凭证提取服务层（数据库查询、解密、AssumeRole）
- **不需要** entrypoint.py（直接启动 server.py）

#### 5.1.2 额外依赖安装（必需）
```dockerfile
RUN pip install --no-cache-dir uv && \
    uv pip install --python /app/.venv/bin/python \
    aws-opentelemetry-distro==0.12.2 \
    sqlalchemy>=2.0.0 \
    psycopg2-binary>=2.9.0 \
    cryptography>=41.0.0
```

**依赖说明**：
| 依赖 | 用途 | 必需性 |
|------|------|--------|
| `aws-opentelemetry-distro` | OpenTelemetry 自动监控（Runtime 要求） | ✅ 必需 |
| `sqlalchemy` | 数据库 ORM，查询 `aws_accounts` 表 | ✅ 必需 |
| `psycopg2-binary` | PostgreSQL 数据库驱动 | ✅ 必需 |
| `cryptography` | Fernet 加密解密（AKSK 解密） | ✅ 必需 |

#### 5.1.3 运行时环境变量（可选配置）
```dockerfile
ENV UV_SYSTEM_PYTHON=1 \
    UV_NO_PROGRESS=1 \
    DOCKER_CONTAINER=1 \
    AWS_REGION=ap-northeast-1 \
    AWS_DEFAULT_REGION=ap-northeast-1
```

**环境变量说明**：
| 变量 | 默认值 | 说明 |
|------|--------|------|
| `AWS_REGION` / `AWS_DEFAULT_REGION` | `ap-northeast-1` | AWS 默认区域（可覆盖） |

#### 5.1.4 端口暴露
```dockerfile
EXPOSE 9000
EXPOSE 8000
EXPOSE 8080
```

#### 5.1.5 启动命令（关键）
```dockerfile
CMD ["opentelemetry-instrument", "python", "-m", "awslabs.cloudtrail_mcp_server.server"]
```

**说明**：
- 使用 `opentelemetry-instrument` 自动注入监控
- 直接启动 server.py 模块（**不需要** entrypoint.py）

---

## 6. 部署脚本

### 6.1 新增文件：costq/scripts/build_and_push_template.sh

**目的**：自动化构建、推送镜像到 ECR 的流程

**核心功能**：
1. 登录 AWS ECR
2. 构建 ARM64 Docker 镜像
3. 打标签（`latest` + 时间戳版本）
4. 推送到 ECR

---

## 7. 数据库设计

### 7.1 表结构
```sql
-- AWS 账号表
CREATE TABLE aws_accounts (
    id UUID PRIMARY KEY,
    account_id VARCHAR(12) UNIQUE NOT NULL,  -- AWS 账号 ID
    alias VARCHAR(255),                      -- 账号别名
    auth_type VARCHAR(20) NOT NULL,          -- 'aksk' | 'iam_role'

    -- AKSK 类型字段
    access_key_id VARCHAR(255),              -- 明文
    secret_access_key_encrypted TEXT,        -- Fernet 加密

    -- IAM Role 类型字段
    role_arn TEXT,                           -- IAM Role ARN

    -- 公共字段
    region VARCHAR(50) DEFAULT 'us-east-1',
    org_id UUID,                             -- 组织 ID（外键）

    FOREIGN KEY (org_id) REFERENCES organizations(id)
);

-- 组织表
CREATE TABLE organizations (
    id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    external_id VARCHAR(255) UNIQUE NOT NULL  -- AssumeRole 使用
);
```

### 7.2 数据库连接配置
**环境变量优先级**：
1. `DATABASE_URL`：直接连接串（开发环境）
2. `RDS_SECRET_NAME`：Secrets Manager 密钥名（生产环境）

**Secrets Manager 格式**：
```json
{
    "username": "postgres",
    "password": "xxx",
    "host": "xxx.rds.amazonaws.com",
    "port": 5432,
    "database": "costq"  // 或 "dbname": "costq" (兼容)
}
```

---

## 8. 环境变量配置

### 8.1 必需环境变量
```bash
# 数据库连接
RDS_SECRET_NAME=xxxx

# AKSK 加密密钥（Fernet，Base64 编码）
ENCRYPTION_KEY=xxxx

# AWS 区域
AWS_REGION=xxxx
```

### 8.2 运行时环境变量（自动设置）
```bash
# boto3 自动识别的标准环境变量
AWS_ACCESS_KEY_ID=xxxx
AWS_SECRET_ACCESS_KEY=xxxx
AWS_SESSION_TOKEN=xxxx  # 临时凭证
AWS_DEFAULT_REGION=xxxx
```

---

## 9. 改造验证清单

### 9.1 功能验证
- [ ] AKSK 账号凭证提取正常
- [ ] IAM Role 账号凭证提取正常
- [ ] External ID 正确传递
- [ ] Session Token 正确处理（有/无）
- [ ] 多账号切换正常
- [ ] 默认凭证（无 target_account_id）正常

### 9.2 异常处理验证
- [ ] 账号不存在 → AccountNotFoundError
- [ ] AKSK 解密失败 → CredentialDecryptionError
- [ ] AssumeRole 失败 → AssumeRoleError
- [ ] 数据库连接失败 → DatabaseConnectionError

### 9.3 安全验证
- [ ] 日志不包含任何凭证信息
- [ ] 错误消息不泄露敏感信息
- [ ] External ID 正确验证

---

## 10. 参数类型兼容性问题

### 10.1 背景：filter_expression 参数类型问题

**问题来源**：在改造 RISP MCP Server 时发现的跨服务通信参数类型不一致问题。

#### 10.1.1 问题现象

**错误信息**：
```
Error executing tool get_sp_coverage: 1 validation error for get_savings_plans_coverage
Arguments\nfilter_expression\n
Input should be a valid string [type=string_type, input_value={'Dimensions': {...}}, input_type=dict]
```

**调用链**：
```
用户/模型
    ↓
FastAPI (CostQ Agent)
    ↓
Bedrock AgentCore Gateway    ← 🔥 序列化行为不一致
    ↓
Bedrock AgentCore Runtime
    ↓
MCP Server (FastMCP)         ← 🔥 Pydantic 验证拦截
    ↓
AWS API
```

#### 10.1.2 根本原因

**三层问题叠加**：

1. **FastMCP Schema 生成缺陷**
   ```python
   # 原始代码
   filter_expression: Annotated[Optional[dict], Field(...)]

   # 生成的 Schema (错误)
   {
     "filter_expression": {
       "anyOf": [
         {},  // ❌ 缺少 "type": "object"
         {"type": "null"}
       ]
     }
   }
   ```

   **问题**: FastMCP 未为 `dict` 类型生成正确的 `type: object` Schema

2. **Gateway 序列化行为不确定**
   - Schema 说 `type: object` → Gateway 序列化为 JSON string ✅
   - Schema 说 `type: string` → Gateway 不序列化,直接传递 ❌
   - Schema 缺少 `type` → Gateway 行为未定义 ❌

3. **Pydantic 验证拦截**
   ```python
   # 函数签名
   filter_expression: Annotated[Optional[str], Field(...)]

   # Pydantic 验证流程
   1. 接收参数 → dict
   2. 检查类型注解 → 期望 str
   3. 类型不匹配 → 抛出 ValidationError ❌
   4. 函数体根本不执行 ❌
   ```

#### 10.1.3 解决方案：Union 类型 + 智能转换

**核心思路**: 在 Pydantic 验证层面就兼容多种类型

```python
from typing import Union

# 1. 参数类型定义：允许 str 和 dict
filter_expression: Annotated[
    Optional[Union[str, dict]],  # ✅ 同时支持两种类型
    Field(
        description=(
            "Filter expression for Cost Explorer API as a JSON string or dict object. "
            "Example: '{\"Dimensions\": {\"Key\": \"SERVICE\", \"Values\": [\"EC2\"]}}'"
        )
    ),
] = None

# 2. 智能类型转换函数
def parse_filter_expression(
    filter_expression: Optional[Union[str, dict]],
    function_name: str
) -> Optional[dict]:
    """解析 filter_expression 参数,支持调试日志.

    Args:
        filter_expression: JSON 字符串或 dict 对象
        function_name: 调用此函数的函数名(用于日志)

    Returns:
        解析后的 dict 或 None
    """
    if not filter_expression:
        return None

    # 🔍 调试日志: 记录接收到的类型
    logger.info(
        "🔍 [%s] filter_expression type: %s",
        function_name,
        type(filter_expression).__name__
    )

    # ⚡ 智能处理: 如果是 dict,直接使用
    if isinstance(filter_expression, dict):
        logger.warning(
            "⚠️ [%s] Received dict instead of string! Auto-converting...",
            function_name
        )
        return filter_expression

    # ✅ 标准处理: JSON 字符串解析
    try:
        return json.loads(filter_expression)
    except json.JSONDecodeError as e:
        logger.error("❌ [%s] Invalid JSON: %s", function_name, str(e))
        raise ValueError(f"Invalid JSON format: {e}")

# 3. 使用方式
async def get_savings_plans_coverage(
    ctx: Context,
    filter_expression: Annotated[Optional[Union[str, dict]], Field(...)] = None,
    ...
) -> dict[str, Any]:
    # 智能解析,自动兼容 str 和 dict
    filter_dict = parse_filter_expression(filter_expression, "get_savings_plans_coverage")

    if filter_dict:
        request_params["Filter"] = filter_dict
```

#### 10.1.4 方案优势

**1. 兼容性 ✅**
- 模型传递 `dict` → Pydantic 验证通过 → `isinstance(dict)` → 直接使用 ✅
- 模型传递 `string` → Pydantic 验证通过 → `json.loads()` → 解析成 dict ✅
- 用户手动传递 `string` → Pydantic 验证通过 → `json.loads()` → 解析成 dict ✅

**2. 鲁棒性 ✅**
- 不依赖 Gateway 的序列化行为
- 防御性编程：在服务边界做好类型兼容
- 向后兼容：支持新旧两种调用方式

**3. 可观测性 ✅**
- 详细的调试日志（类型、值）
- 异常情况警告标记
- 便于问题追踪

#### 10.1.5 改造检查清单

**在改造任何 MCP Server 时,必须检查复杂参数类型**:

- [ ] 是否有 `dict` 类型参数？
- [ ] 是否有嵌套对象参数（如 `List[dict]`）？
- [ ] 参数类型是否明确（避免 `Any`）？
- [ ] 是否支持 `Union[str, dict]` 兼容？
- [ ] 是否有调试日志记录参数类型？

**推荐做法**:

```python
# ✅ 推荐：Union 类型 + 智能转换
complex_param: Annotated[
    Optional[Union[str, dict]],  # 同时支持
    Field(description="JSON string or dict object")
] = None

# ❌ 不推荐：仅支持单一类型
complex_param: Annotated[
    Optional[dict],  # 可能触发 Schema 生成问题
    Field(description="Dict object")
] = None

# ❌ 不推荐：使用 Any (类型不明确)
complex_param: Optional[Any] = None
```

### 10.2 相关文档

**详细分析文档**：
- `costq/docs/20260120_filter_expression分析/问题总结与修复方案.md`
- `costq/docs/20260120_filter_expression分析/step6_根本原因分析.md`

**修复记录**：
- Git Commit: `cb3a41ec`
- 镜像版本: `v20260121-112403`

---

## 11. 后续优化方向

### 11.1 缓存机制
- 临时凭证缓存（避免频繁 AssumeRole）
- 账号信息缓存（减少数据库查询）

### 11.2 并发优化
- 异步数据库查询池
- 连接池管理

### 11.3 监控告警
- 凭证过期监控
- AssumeRole 失败率监控
- 数据库查询性能监控