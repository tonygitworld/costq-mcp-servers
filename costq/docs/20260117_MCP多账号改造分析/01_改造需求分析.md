# MCP Server 多账号权限传递改造需求分析

## 1. 背景说明

### 1.1 架构概述
```
┌─────────────────┐
│ Strands Agent   │  (AgentCore Runtime)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ AgentCore       │  (权限网关)
│ Gateway         │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ MCP Servers     │  (AgentCore Runtime)
│ (多个后端服务)   │
└─────────────────┘
```

### 1.2 核心问题
**问题**：Strands Agent 需要访问**目标账号**的 AWS 资源，但 MCP Server 默认使用**运行时账号**的凭证。

**场景示例**：
- Agent 运行在 Account A (运行时账号)
- 用户想查询 Account B (目标账号) 的成本数据
- MCP Server 需要获取 Account B 的临时凭证

### 1.3 解决方案
通过 **账号上下文传递机制** 实现：
1. Agent 通过 Gateway 传递 `target_account_id` 参数
2. MCP Server 从数据库查询账号凭证信息
3. 根据账号类型（AKSK/IAM Role）获取临时凭证
4. 设置环境变量，boto3 自动使用目标账号凭证

---

## 2. 改造范围

### 2.1 改造的 MCP Server
已改造完成：
- `billing-cost-management-mcp-server`

待改造：
- 其他需要多账号访问能力的 MCP Servers（如 CloudWatch、S3 等）

### 2.1.5 文件可复用性总结

| 文件/目录 | 可复用性 | 需要修改 | 说明 |
|-----------|---------|---------|------|
| `cred_extract_services/` | ✅ **100% 可复用** | ❌ 无需修改 | 完全自包含，不依赖项目代码 |
| `Dockerfile-AgentCore-Runtime` | ✅ **100% 可复用** | ❌ 无需修改 | 通用模板，无硬编码项目名 |
| `entrypoint.py` | ⚠️ **95% 可复用** | ✅ 修改 1 行 | 仅需修改导入路径 |
| `costq/scripts/build_*.sh` | ⚠️ **95% 可复用** | ✅ 修改 1 变量 | 仅需修改 `MCP_SERVER_NAME` |
| `awslabs/.../tools/*.py` | ❌ **需要修改** | ✅ 批量修改 | 所有 tool 函数添加 `target_account_id` 参数 |

**核心优势**：
- ✅ **80% 的基础设施代码可直接复制**
- ✅ **改造时间从 2-3 小时缩短到 10-15 分钟**
- ✅ **降低出错风险**（使用经过验证的代码）

---

### 2.2 改造层级
```
src/billing-cost-management-mcp-server/
├── Dockerfile-AgentCore-Runtime       # ✅ 新增：Runtime 部署专用 Dockerfile
├── entrypoint.py                      # ✅ 新增：统一入口
├── cred_extract_services/             # ✅ 新增：凭证提取服务
│   ├── __init__.py
│   ├── aws_client.py                  # STS AssumeRole
│   ├── context_manager.py             # 环境变量管理
│   ├── credential_extractor.py        # 凭证提取核心
│   ├── crypto.py                      # AKSK 解密
│   ├── database.py                    # 数据库查询
│   └── exceptions.py                  # 自定义异常
├── awslabs/.../tools/                 # ✅ 修改：所有 tool 函数
│   ├── aws_pricing_tools.py
│   ├── budget_tools.py
│   ├── compute_optimizer_tools.py
│   ├── cost_anomaly_tools.py
│   └── ... (其他 tools)
├── awslabs/.../server.py              # ⚠️ 可能需要修改：日志库统一
└── awslabs/.../utilities/             # ✅ 修改：工具函数
    └── aws_service_base.py            # create_aws_client 不变
```

### 2.3 ⚠️ 重要：日志库统一检查

**在改造过程中，必须检查并统一日志库**

#### 2.3.1 为什么重要？

**问题**：混用 `loguru` 和 `logging` 会导致：
- ❌ OpenTelemetry 无法捕获 `loguru` 日志
- ❌ 缺少 trace ID 和 span ID（无法追踪请求链路）
- ❌ CloudWatch 日志不完整
- ❌ 日志格式不一致

**影响**：
- 🔍 **调试困难**：无法通过 trace_id 追踪完整的请求链路
- 📊 **监控不完整**：部分日志缺失导致无法全面分析
- 🚨 **告警不准确**：基于日志的告警可能失效

#### 2.3.2 检查方法

```bash
# 在项目根目录执行
cd src/<mcp-server-name>/
grep -r "from loguru" awslabs/ --include="*.py"

# 如果有输出，需要迁移到 logging
```

**常见情况**：
| 文件 | 使用日志库 | 是否需要迁移 |
|------|-----------|-------------|
| `server.py` | `logging` ✅ | 无需修改 |
| `tools/*.py` | `loguru` ❌ | **需要迁移** |
| `utilities/*.py` | `logging` ✅ | 无需修改 |

#### 2.3.3 快速迁移步骤

**Step 1: 替换导入**
```python
# 修改前
from loguru import logger

# 修改后
import logging
logger = logging.getLogger(__name__)
```

**Step 2: 移除依赖**
```toml
# pyproject.toml
dependencies = [
    "boto3>=1.38.22",
    # "loguru>=0.7.0",  # ❌ 删除
    "mcp[cli]>=1.23.0",
    "pydantic>=2.10.6",
]
```

**Step 3: 验证**
```bash
# 确认没有 loguru 引用
grep -r "loguru" . --include="*.py" --include="*.toml"
```

**参考文档**：
- 详细迁移指南：`costq/docs/20260118_CloudTrail_MCP问题/20250119_loguru_迁移到_logging.md`
- 改造步骤：`02_改造步骤指南.md` Step 4.5

---

## 3. 核心改造点

### 3.1 新增凭证提取服务层 (cred_extract_services/)
**目的**：自包含的凭证管理模块，不依赖项目代码

#### 3.1.1 模块职责
| 模块 | 职责 | 依赖 |
|------|------|------|
| `database.py` | 查询 `aws_accounts` 表和 `organizations` 表 | SQLAlchemy, boto3 (Secrets Manager) |
| `crypto.py` | 解密 AKSK 凭证 (Fernet) | cryptography |
| `aws_client.py` | STS AssumeRole 获取临时凭证 | boto3 |
| `credential_extractor.py` | 凭证提取核心逻辑 | 上述模块 |
| `context_manager.py` | 设置环境变量 (boto3 标准变量) | 无 |
| `exceptions.py` | 自定义异常类 | 无 |

#### 3.1.2 数据库查询逻辑
```sql
SELECT
    a.id, a.account_id, a.alias, a.auth_type,
    a.access_key_id, a.secret_access_key_encrypted,
    a.role_arn, a.region, a.org_id,
    o.external_id  -- 从 organizations 表获取
FROM aws_accounts a
LEFT JOIN organizations o ON a.org_id = o.id
WHERE a.account_id = :account_id
```

**关键字段说明**：
- `auth_type`: "aksk" 或 "iam_role"
- `access_key_id`: AKSK 类型，明文存储
- `secret_access_key_encrypted`: AKSK 类型，Fernet 加密
- `role_arn`: IAM Role 类型
- `external_id`: IAM Role 类型，从 organizations 表获取

#### 3.1.3 凭证提取流程
```python
async def extract_aws_credentials(account_id: str) -> dict:
    # 1. 查询数据库
    account = await query_account(account_id)

    # 2. 根据 auth_type 选择分支
    if account["auth_type"] == "aksk":
        # 解密 Secret Access Key
        secret_key = decrypt_aksk(account["encrypted_secret_key"])
        return {
            "access_key_id": account["access_key_id"],  # 明文
            "secret_access_key": secret_key,
            "session_token": None,
            "region": account["region"],
            "account_id": account["account_id"]
        }

    elif account["auth_type"] == "iam_role":
        # AssumeRole 获取临时凭证
        credentials = await assume_role(
            role_arn=account["role_arn"],
            session_name=f"costq-{uuid.uuid4()}",
            external_id=account["external_id"],  # 必须！
            region=account["region"]
        )
        return {
            "access_key_id": credentials["AccessKeyId"],
            "secret_access_key": credentials["SecretAccessKey"],
            "session_token": credentials["SessionToken"],
            "region": account["region"],
            "account_id": account["account_id"]
        }
```

#### 3.1.4 环境变量设置
```python
def set_aws_credentials(
    access_key_id: str,
    secret_access_key: str,
    session_token: Optional[str] = None,
    region: str = "us-east-1",
) -> None:
    os.environ["AWS_ACCESS_KEY_ID"] = access_key_id
    os.environ["AWS_SECRET_ACCESS_KEY"] = secret_access_key

    # Session Token 处理：有值则设置，无值则删除
    if session_token:
        os.environ["AWS_SESSION_TOKEN"] = session_token
    elif "AWS_SESSION_TOKEN" in os.environ:
        del os.environ["AWS_SESSION_TOKEN"]

    os.environ["AWS_DEFAULT_REGION"] = region
```

**关键点**：
- boto3 自动识别标准环境变量（AWS_ACCESS_KEY_ID、AWS_SECRET_ACCESS_KEY、AWS_SESSION_TOKEN、AWS_DEFAULT_REGION），无需额外配置
- Session Token 的删除逻辑避免残留（AKSK 模式没有 session token）
- 不设置 AWS_ACCOUNT_ID，业务代码通过 STS GetCallerIdentity API 动态获取

---

### 3.2 新增统一入口 (entrypoint.py) - 适用于 fastmcp 独立包

#### 3.2.1 核心函数
```python
async def _setup_account_context(target_account_id: str) -> dict:
    """设置 AWS 凭证上下文

    Args:
        target_account_id: AWS 账号 ID (数据库主键)

    Returns:
        凭证信息字典（已脱敏）

    Raises:
        AccountNotFoundError: 账号不存在
        CredentialDecryptionError: AKSK 解密失败
        AssumeRoleError: IAM Role AssumeRole 失败
        DatabaseConnectionError: 数据库连接失败
    """
    # 1. 提取凭证
    credentials = await extract_aws_credentials(target_account_id)

    # 2. 设置环境变量
    set_aws_credentials(
        access_key_id=credentials["access_key_id"],
        secret_access_key=credentials["secret_access_key"],
        session_token=credentials.get("session_token"),
        region=credentials["region"],
    )

    # 3. 返回脱敏信息
    return {
        "account_id": credentials["account_id"],
        "account_alias": credentials.get("alias", "Unknown"),
        "auth_type": credentials["auth_type"],
        "region": credentials["region"]
    }
```

#### 3.2.2 主函数修改（fastmcp 独立包）
```python
def main():
    """启动 MCP Server

    环境变量配置：
        FASTMCP_TRANSPORT: 'stdio' | 'streamable-http' (默认)
        FASTMCP_HOST: 默认 '0.0.0.0'
        FASTMCP_PORT: 默认 8000
        FASTMCP_STATELESS_HTTP: 默认 'true'
    """
    from awslabs.billing_cost_management_mcp_server.server import mcp, setup

    transport = os.environ.get("FASTMCP_TRANSPORT", "streamable-http")
    host = os.environ.get("FASTMCP_HOST", "0.0.0.0")
    port = int(os.environ.get("FASTMCP_PORT", "8000"))
    stateless = os.environ.get("FASTMCP_STATELESS_HTTP", "true").lower() == "true"

    asyncio.run(setup())  # 初始化 server

    if transport == "stdio":
        mcp.run(transport=transport)
    else:
        mcp.run(transport=transport, host=host, port=port, stateless_http=stateless)
```

---

### 3.3 新改造方案：直接在 server.py 配置（mcp.server.fastmcp）

**适用于**：使用 `mcp.server.fastmcp`（MCP SDK 内置）的项目

**核心发现**：`mcp.server.fastmcp.FastMCP` 支持在初始化时传递 `host` 和 `stateless_http` 参数！

#### 3.3.1 server.py 改造示例
```python
from mcp.server.fastmcp import FastMCP

# Create FastMCP server for AgentCore Runtime
# AgentCore requires stateless HTTP servers on 0.0.0.0:8000/mcp
mcp = FastMCP(
    name='awslabs.cloudtrail-mcp-server',
    instructions='...',
    dependencies=[...],
    host="0.0.0.0",           # ← 新增：监听地址
    stateless_http=True       # ← 新增：无状态 HTTP 模式
)

# 注册工具
cloudtrail_tools = CloudTrailTools()
cloudtrail_tools.register(mcp)

def main():
    """Run the MCP server with streamable HTTP transport for AgentCore."""
    # AgentCore Runtime expects servers to run with streamable-http transport
    mcp.run(transport="streamable-http")  # ← 只传 transport

if __name__ == '__main__':
    main()
```

#### 3.3.2 优势对比

| 方案 | fastmcp 独立包 + entrypoint.py | mcp.server.fastmcp + server.py 配置 |
|------|-------------------------------|-----------------------------------|
| **配置位置** | entrypoint.py 读取环境变量 | server.py 初始化时传参 |
| **代码复杂度** | 需要额外的 entrypoint.py | 直接在 server.py 配置 |
| **环境变量** | 需要 FASTMCP_* 环境变量 | 不依赖环境变量 |
| **run() 调用** | `mcp.run(transport, host, port, stateless_http)` | `mcp.run(transport="streamable-http")` |
| **多账号支持** | ✅ 支持（需要 entrypoint.py） | ✅ 支持（需要 entrypoint.py） |
| **适用项目** | billing-cost-management | cloudtrail, cost-explorer 等 |

#### 3.3.3 改造步骤

**Step 1：修改 server.py**
```python
# 原始代码
mcp = FastMCP(
    'awslabs.cloudtrail-mcp-server',
    instructions='...',
)

# 改造后
mcp = FastMCP(
    name='awslabs.cloudtrail-mcp-server',  # 使用 name= 参数
    instructions='...',
    host="0.0.0.0",           # 新增
    stateless_http=True       # 新增
)
```

**Step 2：修改 main() 函数**
```python
# 原始代码
def main():
    mcp.run()

# 改造后
def main():
    """Run the MCP server with streamable HTTP transport for AgentCore."""
    # AgentCore Runtime expects servers to run with streamable-http transport
    mcp.run(transport="streamable-http")
```

**Step 3：删除 entrypoint.py（如果只做 AgentCore Runtime 部署）**
- 如果不需要多账号功能，可以删除 entrypoint.py
- Dockerfile 改为直接启动 server.py

**Step 4：更新 Dockerfile**
```dockerfile
# 如果不需要多账号功能
CMD ["awslabs.cloudtrail-mcp-server"]  # 直接启动

# 如果需要多账号功能（保留 entrypoint.py）
CMD ["opentelemetry-instrument", "python", "-m", "entrypoint"]
```

#### 3.3.4 验证方法

**启动后检查日志**：
```
INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
```

✅ **成功标志**：绑定到 `0.0.0.0:8000`（而不是 `127.0.0.1:8000`）

**测试 HTTP 连接**：
```bash
curl http://localhost:8000/
# 预期返回：404（正常，因为访问根路径）
```

#### 3.3.5 两种方案选择指南

| 场景 | 推荐方案 | 理由 |
|------|---------|------|
| **已使用 fastmcp 独立包** | 方案 1（entrypoint.py） | 保持一致性 |
| **已使用 mcp.server.fastmcp** | 方案 2（server.py 配置） | 代码更简洁 |
| **需要多账号支持** | 两者都需要 entrypoint.py | 账号上下文初始化 |
| **仅 AgentCore Runtime 部署** | 方案 2（server.py 配置） | 不需要额外文件 |
| **本地测试 + 生产部署** | 方案 1（entrypoint.py） | 环境变量灵活配置 |

---

### 3.3 修改所有 Tool 函数

#### 3.3.1 参数修改模式
**所有 tool 函数都新增参数**：
```python
@server.tool(name="tool-name", description="...")
async def tool_function(
    ctx: Context,
    target_account_id: Optional[str] = None,  # ✅ 新增参数
    # ... 其他业务参数
) -> Dict[str, Any]:
```

#### 3.3.2 标准改造模板
```python
async def tool_function(
    ctx: Context,
    target_account_id: Optional[str] = None,
    # ... 业务参数
) -> Dict[str, Any]:
    try:
        # ===== 账号上下文初始化 =====
        if target_account_id:
            from entrypoint import _setup_account_context
            await _setup_account_context(target_account_id)

        # ===== 原有逻辑（完全不变）=====
        # ... 业务代码

    # ===== 异常处理 =====
    except AccountNotFoundError:
        return format_response('error', {'error_type': 'account_not_found'},
                               'Account not found. Please check the account ID.')
    except CredentialDecryptionError:
        return format_response('error', {'error_type': 'credential_error'},
                               'Failed to decrypt credentials. Please contact administrator.')
    except AssumeRoleError:
        return format_response('error', {'error_type': 'assume_role_error'},
                               'Failed to assume role. Please check IAM role configuration.')
    except DatabaseConnectionError:
        return format_response('error', {'error_type': 'database_error'},
                               'Database connection failed. Please try again later.')
    except Exception as e:
        return await handle_aws_error(ctx, e, 'operation', 'Service Name')
```

#### 3.3.3 异常处理
**导入自定义异常**：
```python
from entrypoint import (
    AccountNotFoundError,
    CredentialDecryptionError,
    AssumeRoleError,
    DatabaseConnectionError,
)
```

**统一错误返回格式**：
```python
{
    "status": "error",
    "data": {
        "error_type": "account_not_found" | "credential_error" | "assume_role_error" | "database_error"
    },
    "message": "User-friendly error message"
}
```

---

### 3.4 工具函数保持不变

#### 3.4.1 aws_service_base.py
```python
def create_aws_client(service_name: str, region_name: Optional[str] = None) -> Any:
    """创建 AWS 客户端（逻辑完全不变）

    boto3 会自动从环境变量读取凭证：
    - AWS_ACCESS_KEY_ID
    - AWS_SECRET_ACCESS_KEY
    - AWS_SESSION_TOKEN (可选)
    - AWS_DEFAULT_REGION
    """
    # ... 原有逻辑不变
    session = boto3.Session(region_name=region)
    return session.client(service_name, config=config)
```

**关键点**：
- 不需要修改任何 `create_aws_client` 调用
- boto3 自动从环境变量读取凭证
- **零侵入性原则**：业务代码无感知

---

## 4. 改造原则总结

### 4.1 零侵入性原则
✅ **仅修改目标代码，不改变业务逻辑和函数签名**

- Tool 函数新增可选参数 `target_account_id`
  - **参数位置规则**：必须放在所有必需参数之后、其他可选参数之前
  - **示例**：`async def tool(ctx, required_param, target_account_id=None, optional_param=None)`
- 业务逻辑完全不变
- 工具函数（`create_aws_client`）不变

### 4.2 自包含原则
✅ **凭证提取服务完全独立**

- `cred_extract_services/` 不依赖项目代码
- 可以单独测试、复用

### 4.3 安全原则
✅ **日志安全**

- 不记录任何敏感信息（密码、密钥、凭证、连接串）
- 仅记录操作结果和元数据

✅ **异常安全**

- 统一的自定义异常类型
- 清晰的错误提示

### 4.4 环境变量原则
✅ **标准化**

- 使用 boto3 标准环境变量
- 不自定义 boto3 配置

✅ **生命周期管理**

- Session Token 有值则设置，无值则删除
- 避免环境变量残留

---

## 5. Dockerfile 改造详解

### 5.1 新增文件：Dockerfile-AgentCore-Runtime

**目的**：构建专门用于 AgentCore Runtime 部署的 ARM64 镜像

**关键改造点**：

#### 5.1.1 文件复制（必需）
```dockerfile
# 复制 entrypoint.py 和 cred_extract_services（改造核心）
COPY --chown=app:app ./entrypoint.py /app/entrypoint.py
COPY --chown=app:app ./cred_extract_services /app/cred_extract_services
```

**说明**：
- `entrypoint.py`：统一入口，包含账号上下文初始化逻辑
- `cred_extract_services/`：凭证提取服务层（数据库查询、解密、AssumeRole）

#### 5.1.2 额外依赖安装（必需）
```dockerfile
RUN pip install --no-cache-dir uv && \
    uv pip install --python /app/.venv/bin/python \
    aws-opentelemetry-distro==0.12.2 \
    sqlalchemy>=2.0.0 \
    psycopg2-binary>=2.9.0 \
    cryptography>=41.0.0
```

**依赖说明**：
| 依赖 | 用途 | 必需性 |
|------|------|--------|
| `aws-opentelemetry-distro` | OpenTelemetry 自动监控（Runtime 要求） | ✅ 必需 |
| `sqlalchemy` | 数据库 ORM，查询 `aws_accounts` 表 | ✅ 必需 |
| `psycopg2-binary` | PostgreSQL 数据库驱动 | ✅ 必需 |
| `cryptography` | Fernet 加密解密（AKSK 解密） | ✅ 必需 |

#### 5.1.3 运行时环境变量（可选配置）
```dockerfile
ENV UV_SYSTEM_PYTHON=1 \
    UV_NO_PROGRESS=1 \
    DOCKER_CONTAINER=1 \
    AWS_REGION=ap-northeast-1 \
    AWS_DEFAULT_REGION=ap-northeast-1 \
    FASTMCP_HOST=0.0.0.0 \
    FASTMCP_PORT=8000 \
    FASTMCP_STATELESS_HTTP=true \
    FASTMCP_TRANSPORT=streamable-http
```

**环境变量说明**：
| 变量 | 默认值 | 说明 |
|------|--------|------|
| `AWS_REGION` / `AWS_DEFAULT_REGION` | `ap-northeast-1` | AWS 默认区域（可覆盖） |
| `FASTMCP_HOST` | `0.0.0.0` | MCP Server 监听地址 |
| `FASTMCP_PORT` | `8000` | MCP Server 监听端口 |
| `FASTMCP_STATELESS_HTTP` | `true` | 无状态 HTTP 模式 |
| `FASTMCP_TRANSPORT` | `streamable-http` | 传输协议 |

#### 5.1.4 端口暴露
```dockerfile
EXPOSE 9000
EXPOSE 8000
EXPOSE 8080
```

#### 5.1.5 启动命令（关键）
```dockerfile
CMD ["opentelemetry-instrument", "python", "-m", "entrypoint"]
```

**说明**：
- 使用 `opentelemetry-instrument` 自动注入监控
- 启动 `entrypoint` 模块（自定义入口点，非 FastMCP 默认入口）

---

### 5.2 Dockerfile 与原始版本对比

| 改造点 | 原始 Dockerfile | Dockerfile-AgentCore-Runtime |
|--------|----------------|------------------------------|
| 文件复制 | 只复制 `awslabs/` 包 | 额外复制 `entrypoint.py` + `cred_extract_services/` |
| 额外依赖 | 无 | SQLAlchemy、psycopg2、cryptography、OpenTelemetry |
| 启动命令 | `python -m awslabs.<package>` | `opentelemetry-instrument python -m entrypoint` |
| 端口暴露 | 仅 8000 | 8000、8080、9000 |
| 环境变量 | 最小化 | 完整的 MCP + AWS 配置 |

---

### 5.3 为什么需要单独的 Dockerfile？

**原因**：

1. **部署环境不同**
   - 原始：本地开发、测试
   - Runtime：AWS AgentCore 生产环境

2. **依赖不同**
   - 原始：只需要业务依赖
   - Runtime：需要数据库、加密、监控依赖

3. **入口不同**
   - 原始：直接启动 FastMCP Server
   - Runtime：需要先初始化账号上下文（`entrypoint.py`）

4. **监控要求不同**
   - 原始：无监控
   - Runtime：必须集成 OpenTelemetry

---

## 6. 部署脚本

### 6.1 新增文件：costq/scripts/01-build_and_push_<mcp-server-name>.sh

**目的**：自动化构建、推送镜像到 ECR 的流程

**核心功能**：
1. 登录 AWS ECR
2. 构建 ARM64 Docker 镜像
3. 打标签（`latest` + 时间戳版本）
4. 推送到 ECR

---

### 6.2 脚本结构

```bash
#!/bin/bash
#
# 构建 Docker 镜像并推送到 ECR
#
# 用途：将 MCP Server 打包成 ARM64 镜像并上传到 AWS ECR
#

set -e  # 遇到错误立即退出

# =============================================================================
# 配置（需要根据具体 MCP Server 修改）
# =============================================================================
AWS_PROFILE="3532"
AWS_REGION="ap-northeast-1"
AWS_ACCOUNT="000451883532"
ECR_REPO="awslabs-mcp/<mcp-server-name>"  # ✅ 修改此处
IMAGE_TAG="v$(date +%Y%m%d-%H%M%S)"

# 计算完整的 ECR URI
ECR_URI="${AWS_ACCOUNT}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}"
FULL_IMAGE="${ECR_URI}:${IMAGE_TAG}"

# =============================================================================
# Step 1: 登录 ECR
# =============================================================================
echo "🔐 Step 1: 登录 ECR..."
AWS_PROFILE=${AWS_PROFILE} aws ecr get-login-password --region ${AWS_REGION} | \
  docker login --username AWS --password-stdin ${AWS_ACCOUNT}.dkr.ecr.${AWS_REGION}.amazonaws.com

# =============================================================================
# Step 2: 构建 ARM64 镜像
# =============================================================================
echo "🔨 Step 2: 构建 ARM64 Docker 镜像..."

# 获取脚本所在目录，然后切换到项目根目录
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
MCP_SERVER_DIR="${PROJECT_ROOT}/src/<mcp-server-name>"  # ✅ 修改此处

cd "${MCP_SERVER_DIR}"

docker buildx build \
  --platform linux/arm64 \
  -f Dockerfile-AgentCore-Runtime \
  -t ${FULL_IMAGE} \
  --load \
  .

# =============================================================================
# Step 3: 打标签并推送
# =============================================================================
echo "🏷️  Step 3: 打标签..."
docker tag ${FULL_IMAGE} ${ECR_URI}:latest

echo "📤 Step 4: 推送镜像到 ECR..."
docker push ${FULL_IMAGE}
docker push ${ECR_URI}:latest

# =============================================================================
# 完成
# =============================================================================
echo "✅ 镜像部署完成!"
echo "镜像 URI: ${FULL_IMAGE}"
```

---

### 6.3 脚本使用方法

#### 6.3.1 创建脚本
```bash
# 在 costq/scripts/ 目录下创建
cd costq/scripts/
touch 01-build_and_push_<mcp-server-name>.sh
chmod +x 01-build_and_push_<mcp-server-name>.sh
```

#### 6.3.2 修改配置
**需要修改的变量**：
| 变量 | 说明 | 示例 |
|------|------|------|
| `ECR_REPO` | ECR 仓库路径 | `awslabs-mcp/billing-cost-management-mcp-server` |
| `MCP_SERVER_DIR` | MCP Server 源码路径 | `${PROJECT_ROOT}/src/billing-cost-management-mcp-server` |
| `AWS_PROFILE` | AWS CLI Profile（可选） | `3532` |
| `AWS_REGION` | AWS 区域（可选） | `ap-northeast-1` |

#### 6.3.3 执行脚本
```bash
# 从项目根目录执行
bash costq/scripts/01-build_and_push_<mcp-server-name>.sh
```

**预期输出**：
```
============================================================
🚀 构建并推送 CostQ Agent 镜像
============================================================
ECR 仓库: 000451883532.dkr.ecr.ap-northeast-1.amazonaws.com/awslabs-mcp/...
镜像标签: latest, v20260117-101036
平台: linux/arm64
============================================================

🔐 Step 1: 登录 ECR...
✅ ECR 登录成功

🔨 Step 2: 构建 ARM64 Docker 镜像...
...
✅ 镜像构建成功

🏷️  Step 3: 打标签...
✅ 标签已创建: latest, v20260117-101036

📤 Step 4: 推送镜像到 ECR...
✅ 镜像推送成功

============================================================
✅ 镜像部署完成!
============================================================
```

---

### 6.4 脚本特性

**优点**：
- ✅ 自动化：一键完成构建和推送
- ✅ 错误处理：遇到错误立即退出（`set -e`）
- ✅ 友好输出：清晰的步骤提示和 emoji 标识
- ✅ 版本管理：自动生成时间戳版本号
- ✅ 双标签：同时推送 `latest` 和时间戳版本

**注意事项**：
- ⚠️ 只构建和推送镜像，**不更新 Runtime**
- ⚠️ 需要手动执行 `aws bedrock-agentcore-control update-runtime`
- ⚠️ 推送后需要**刷新 Gateway**（参考 DEEPV.md）

---

### 6.5 后续手动步骤

**脚本完成后，还需要**：

1. **更新 Runtime**
   ```bash
   aws bedrock-agentcore-control update-runtime \
     --profile 3532 \
     --region ap-northeast-1 \
     --runtime-identifier <runtime-id> \
     --container-image <ecr-url>/<mcp-server-name>:latest
   ```

2. **刷新 Gateway**
   - 按照 DEEPV.md 中的说明操作
   - 确保新镜像生效

3. **验证部署**
   ```bash
   # 查看日志
   kubectl logs -f -n costq-fastapi deployment/costq-fastapi

   # 测试健康检查
   curl http://<gateway-url>/health
   ```

---

## 7. 数据库设计

### 7.1 表结构
```sql
-- AWS 账号表
CREATE TABLE aws_accounts (
    id UUID PRIMARY KEY,
    account_id VARCHAR(12) UNIQUE NOT NULL,  -- AWS 账号 ID
    alias VARCHAR(255),                      -- 账号别名
    auth_type VARCHAR(20) NOT NULL,          -- 'aksk' | 'iam_role'

    -- AKSK 类型字段
    access_key_id VARCHAR(255),              -- 明文
    secret_access_key_encrypted TEXT,        -- Fernet 加密

    -- IAM Role 类型字段
    role_arn TEXT,                           -- IAM Role ARN

    -- 公共字段
    region VARCHAR(50) DEFAULT 'us-east-1',
    org_id UUID,                             -- 组织 ID（外键）

    FOREIGN KEY (org_id) REFERENCES organizations(id)
);

-- 组织表
CREATE TABLE organizations (
    id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    external_id VARCHAR(255) UNIQUE NOT NULL  -- AssumeRole 使用
);
```

### 5.2 数据库连接配置
**环境变量优先级**：
1. `DATABASE_URL`：直接连接串（开发环境）
2. `RDS_SECRET_NAME`：Secrets Manager 密钥名（生产环境）

**Secrets Manager 格式**：
```json
{
    "username": "postgres",
    "password": "xxx",
    "host": "xxx.rds.amazonaws.com",
    "port": 5432,
    "database": "costq"  // 或 "dbname": "costq" (兼容)
}
```

---

## 6. 环境变量配置

### 6.1 必需环境变量
```bash
# 数据库连接
RDS_SECRET_NAME=xxxx

# AKSK 加密密钥（Fernet，Base64 编码）
ENCRYPTION_KEY=xxxx

# AWS 区域
AWS_REGION=xxxx

# MCP Server 传输配置
FASTMCP_TRANSPORT=streamable-http    # 或 stdio
FASTMCP_HOST=0.0.0.0
FASTMCP_PORT=8000
FASTMCP_STATELESS_HTTP=true
```

### 6.2 运行时环境变量（自动设置）
```bash
# boto3 自动识别的标准环境变量
AWS_ACCESS_KEY_ID=xxxx
AWS_SECRET_ACCESS_KEY=xxxx
AWS_SESSION_TOKEN=xxxx  # 临时凭证
AWS_DEFAULT_REGION=xxxx
```

---

## 7. 改造验证清单

### 7.1 功能验证
- [ ] AKSK 账号凭证提取正常
- [ ] IAM Role 账号凭证提取正常
- [ ] External ID 正确传递
- [ ] Session Token 正确处理（有/无）
- [ ] 多账号切换正常
- [ ] 默认凭证（无 target_account_id）正常

### 7.2 异常处理验证
- [ ] 账号不存在 → AccountNotFoundError
- [ ] AKSK 解密失败 → CredentialDecryptionError
- [ ] AssumeRole 失败 → AssumeRoleError
- [ ] 数据库连接失败 → DatabaseConnectionError

### 7.3 安全验证
- [ ] 日志不包含任何凭证信息
- [ ] 错误消息不泄露敏感信息
- [ ] External ID 正确验证

---

## 8. 后续优化方向

### 8.1 缓存机制
- 临时凭证缓存（避免频繁 AssumeRole）
- 账号信息缓存（减少数据库查询）

### 8.2 并发优化
- 异步数据库查询池
- 连接池管理

### 8.3 监控告警
- 凭证过期监控
- AssumeRole 失败率监控
- 数据库查询性能监控
