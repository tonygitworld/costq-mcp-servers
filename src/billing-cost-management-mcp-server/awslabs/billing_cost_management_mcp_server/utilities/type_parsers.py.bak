"""Type parsing utilities for handling parameter type conversions.

This module provides standardized functions to parse parameters that may
be passed in different formats due to Gateway serialization behavior.

Key Features:
- Support for complex objects (dict, list)
- Support for basic types (int, float)
- Detailed logging with emoji markers (ğŸ”âš ï¸âœ…âŒ)
- Comprehensive error handling
- Range validation for numeric types

Usage:
    from awslabs.billing_cost_management_mcp_server.utilities.type_parsers import (
        parse_complex_param,
        parse_int_param,
        parse_float_param
    )

    # Complex object
    filter_dict = parse_complex_param(
        filter_expression,
        "my_function",
        "filter_expression"
    )

    # Integer
    max_results = parse_int_param(
        max_results,
        "my_function",
        "max_results",
        min_value=1,
        max_value=100
    )

Author: CostQ Development Team
Date: 2026-01-22
"""

import json
import logging
from typing import Any, List, Optional, Union

logger = logging.getLogger(__name__)


def parse_complex_param(
    param: Optional[Union[str, dict, list]],
    function_name: str,
    param_name: str = "complex_param"
) -> Optional[Union[dict, List]]:
    """è§£æå¤æ‚å‚æ•°,æ”¯æŒ JSON å­—ç¬¦ä¸²å’Œ dict/list å¯¹è±¡.

    Args:
        param: JSON å­—ç¬¦ä¸²æˆ– dict/list å¯¹è±¡
        function_name: è°ƒç”¨æ­¤å‡½æ•°çš„å‡½æ•°å(ç”¨äºæ—¥å¿—)
        param_name: å‚æ•°å(ç”¨äºæ—¥å¿—)

    Returns:
        è§£æåçš„ dict/list æˆ– None

    Raises:
        ValueError: JSON æ ¼å¼æ— æ•ˆ

    Examples:
        >>> # Dict è¾“å…¥
        >>> parse_complex_param({"key": "value"}, "test_func", "filter")
        {'key': 'value'}

        >>> # JSON å­—ç¬¦ä¸²è¾“å…¥
        >>> parse_complex_param('{"key": "value"}', "test_func", "filter")
        {'key': 'value'}

        >>> # None è¾“å…¥
        >>> parse_complex_param(None, "test_func", "filter")
        None
    """
    if not param:
        return None

    # ğŸ” è°ƒè¯•æ—¥å¿—: è®°å½•æ¥æ”¶åˆ°çš„ç±»å‹
    logger.info(
        "ğŸ” [%s] %s type: %s, value: %s",
        function_name,
        param_name,
        type(param).__name__,
        str(param)[:200]  # é™åˆ¶é•¿åº¦é¿å…æ—¥å¿—è¿‡é•¿
    )

    # âš¡ æ™ºèƒ½å¤„ç†: å¦‚æœæ˜¯ dict/list,ç›´æ¥ä½¿ç”¨
    if isinstance(param, (dict, list)):
        logger.warning(
            "âš ï¸ [%s] Received %s for %s instead of string! Auto-converting...",
            function_name,
            type(param).__name__,
            param_name
        )
        return param

    # âœ… æ ‡å‡†å¤„ç†: JSON å­—ç¬¦ä¸²è§£æ
    if isinstance(param, str):
        try:
            parsed = json.loads(param)
            logger.info("âœ… [%s] Successfully parsed %s", function_name, param_name)
            return parsed
        except json.JSONDecodeError as e:
            logger.error(
                "âŒ [%s] Invalid JSON format for %s: %s",
                function_name,
                param_name,
                str(e)
            )
            raise ValueError(f"Invalid JSON format for {param_name}: {e}")

    # å…¶ä»–ç±»å‹
    raise ValueError(
        f"{param_name} must be string, dict, or list, got {type(param).__name__}"
    )


def parse_int_param(
    param: Optional[Union[str, int]],
    function_name: str,
    param_name: str = "int_param",
    default: Optional[int] = None,
    min_value: Optional[int] = None,
    max_value: Optional[int] = None
) -> Optional[int]:
    """è§£ææ•´æ•°å‚æ•°,æ”¯æŒå­—ç¬¦ä¸²å’Œæ•´æ•°è¾“å…¥.

    Args:
        param: å­—ç¬¦ä¸²æˆ–æ•´æ•°
        function_name: è°ƒç”¨æ­¤å‡½æ•°çš„å‡½æ•°å(ç”¨äºæ—¥å¿—)
        param_name: å‚æ•°å(ç”¨äºæ—¥å¿—)
        default: é»˜è®¤å€¼(å½“ param ä¸º None æ—¶è¿”å›)
        min_value: æœ€å°å€¼(å¯é€‰)
        max_value: æœ€å¤§å€¼(å¯é€‰)

    Returns:
        è§£æåçš„æ•´æ•°æˆ– None

    Raises:
        ValueError: å‚æ•°æ ¼å¼æ— æ•ˆæˆ–è¶…å‡ºèŒƒå›´

    Examples:
        >>> # æ•´æ•°è¾“å…¥
        >>> parse_int_param(50, "test_func", "max_results")
        50

        >>> # å­—ç¬¦ä¸²è¾“å…¥
        >>> parse_int_param("50", "test_func", "max_results")
        50

        >>> # None è¾“å…¥å¸¦é»˜è®¤å€¼
        >>> parse_int_param(None, "test_func", "max_results", default=100)
        100

        >>> # èŒƒå›´éªŒè¯
        >>> parse_int_param(150, "test_func", "max_results", max_value=100)
        Traceback (most recent call last):
        ...
        ValueError: max_results must be <= 100, got 150
    """
    if param is None:
        return default

    # ğŸ” è°ƒè¯•æ—¥å¿—: è®°å½•æ¥æ”¶åˆ°çš„ç±»å‹
    logger.info(
        "ğŸ” [%s] %s type: %s, value: %s",
        function_name,
        param_name,
        type(param).__name__,
        str(param)
    )

    # âš¡ æ™ºèƒ½å¤„ç†: å¦‚æœæ˜¯ int,ç›´æ¥ä½¿ç”¨
    if isinstance(param, int):
        result = param
    # âš ï¸ å¦‚æœæ˜¯å­—ç¬¦ä¸²,å°è¯•è½¬æ¢
    elif isinstance(param, str):
        logger.warning(
            "âš ï¸ [%s] Received string for %s instead of int! Auto-converting...",
            function_name,
            param_name
        )
        try:
            result = int(param)
        except ValueError as e:
            logger.error(
                "âŒ [%s] Invalid integer format for %s: %s",
                function_name,
                param_name,
                str(e)
            )
            raise ValueError(f"Invalid integer format for {param_name}: {e}")
    else:
        raise ValueError(
            f"{param_name} must be string or int, got {type(param).__name__}"
        )

    # èŒƒå›´éªŒè¯
    if min_value is not None and result < min_value:
        raise ValueError(f"{param_name} must be >= {min_value}, got {result}")
    if max_value is not None and result > max_value:
        raise ValueError(f"{param_name} must be <= {max_value}, got {result}")

    return result


def parse_float_param(
    param: Optional[Union[str, float, int]],
    function_name: str,
    param_name: str = "float_param",
    default: Optional[float] = None,
    min_value: Optional[float] = None,
    max_value: Optional[float] = None
) -> Optional[float]:
    """è§£ææµ®ç‚¹æ•°å‚æ•°,æ”¯æŒå­—ç¬¦ä¸²ã€æµ®ç‚¹æ•°å’Œæ•´æ•°è¾“å…¥.

    Args:
        param: å­—ç¬¦ä¸²ã€æµ®ç‚¹æ•°æˆ–æ•´æ•°
        function_name: è°ƒç”¨æ­¤å‡½æ•°çš„å‡½æ•°å(ç”¨äºæ—¥å¿—)
        param_name: å‚æ•°å(ç”¨äºæ—¥å¿—)
        default: é»˜è®¤å€¼(å½“ param ä¸º None æ—¶è¿”å›)
        min_value: æœ€å°å€¼(å¯é€‰)
        max_value: æœ€å¤§å€¼(å¯é€‰)

    Returns:
        è§£æåçš„æµ®ç‚¹æ•°æˆ– None

    Raises:
        ValueError: å‚æ•°æ ¼å¼æ— æ•ˆæˆ–è¶…å‡ºèŒƒå›´

    Examples:
        >>> # æµ®ç‚¹æ•°è¾“å…¥
        >>> parse_float_param(3.14, "test_func", "timeout")
        3.14

        >>> # æ•´æ•°è¾“å…¥
        >>> parse_float_param(50, "test_func", "timeout")
        50.0

        >>> # å­—ç¬¦ä¸²è¾“å…¥
        >>> parse_float_param("3.14", "test_func", "timeout")
        3.14
    """
    if param is None:
        return default

    # ğŸ” è°ƒè¯•æ—¥å¿—
    logger.info(
        "ğŸ” [%s] %s type: %s, value: %s",
        function_name,
        param_name,
        type(param).__name__,
        str(param)
    )

    # âš¡ æ™ºèƒ½å¤„ç†
    if isinstance(param, (float, int)):
        result = float(param)
    elif isinstance(param, str):
        logger.warning(
            "âš ï¸ [%s] Received string for %s instead of float! Auto-converting...",
            function_name,
            param_name
        )
        try:
            result = float(param)
        except ValueError as e:
            logger.error(
                "âŒ [%s] Invalid float format for %s: %s",
                function_name,
                param_name,
                str(e)
            )
            raise ValueError(f"Invalid float format for {param_name}: {e}")
    else:
        raise ValueError(
            f"{param_name} must be string, float, or int, got {type(param).__name__}"
        )

    # èŒƒå›´éªŒè¯
    if min_value is not None and result < min_value:
        raise ValueError(f"{param_name} must be >= {min_value}, got {result}")
    if max_value is not None and result > max_value:
        raise ValueError(f"{param_name} must be <= {max_value}, got {result}")

    return result


__all__ = [
    'parse_complex_param',
    'parse_int_param',
    'parse_float_param',
]
